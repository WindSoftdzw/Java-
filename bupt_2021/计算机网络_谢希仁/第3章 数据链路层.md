# 第3章 数据链路层

数据链路层属于计算机网络的底层。数据链路层使用的信道主要有以下两种类型：

1. **点对点信道**	这种信道使用一对一的点对点通信方式
2. **广播信道**	这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。

## 1.使用点对点信道的数据链路

### 1.1数据链路和帧

所谓**链路**就是从一个结点**到相邻结点**的一段物理线路（有线或无线），而中间没有任何其他的交换节点。

**数据链路**（data link）则是另一个概念。若把实现一些必要的控制数据传输的通信协议的硬件和软件加到链路上，就构成了数据链路。

数据链路层把网络层交下来的数据构成**帧**发送到链路上，以及把接收到的**帧**中的数据取出并上交给网络层。在因特网中，网络层协议数据单元就是IP数据报。

点对点信道的数据链路层在进行通信时的主要步骤如下：

1. 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。
2. 结点A把封装好的帧发送给结点B的数据链路层。
3. 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层；否则丢弃这个帧。

数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想**好像是**沿着两个数据链路层之间的水平方向把帧直接发送到对方。

### 1.2三个基本问题

数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题就是：**封装成帧**、**透明传输**、和**差错检测**。

#### （1）封装成帧

**封装成帧**（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行**帧定界**。在发送帧时，是从帧首部开始发送。为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是每一种链路层协议都规定了所能传送的帧的**数据部分长度上限——传送单元MTU**（Maximum Transfer Unit）。

当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的**帧定界符**。

#### （2）透明传输

由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何8比特的组合不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。

但当数据部分是非ASCII码的文本文件时，情况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这样的帧定界控制字符一样，数据链路层就会**错误地**“找到帧的边界”，把部分帧收下，而把剩下的那部分数据丢弃。

“**透明**”是一个很重要的术语。它表示：**某一个实际存在的事物看起来却是好像不存在一样**。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据都能够通过这个数据链路层。

为了解决透明传输问题，就必须设法使**数据中**可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。具体的方法是：发送端的数据链路层在数据中出现控制字符“SOH”和“EOT”的前面插入一个**转义字符**“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为**字节填充**或**字符填充**。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中最前面的一个。

#### （3）差错检测

比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1.这就叫做“**比特差错**”。在一段时间内，传输错误的比特总数的比率称为**误码率BER**（Bit Error Rate）。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并非是理想的，它不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了**循环冗余检验CRC**的检错技术。

n位冗余码可用以下方法得出。用二进制的**模2运算**进行$2^n$乘数据M的运算，这相当于在数据M后面添加n个0。得到的(k+n)位的数**除以**双方事先商定的长度为(n+1)位的除数P，得出商是Q而**余数**是R。关于除数P下面还要介绍。这个余数R就作为冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码常称为**帧检验序列FCS**（Frame Check Sequence）。

在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以同样的除数P，然后检查得到的余数R。如果在传输过程中无差错，那么经过CRC检验后得出的余数R肯定是0。

总之，在接收端对收到的每一帧经过CRC检验后，有以下两种情况：

（1）若得出的余数R = 0，则判定这个帧没有差错，就接受。

（2）若余数R $\neq$ 0，则判定这个帧有差错，就丢弃。

