# 体系结构与组成


###### 2019/7/12

### 1.存储程序计算机

ARM这一类处理器采用了存储程序体系结构，它将程序和数据放在同一个存储空间内，采用**取指-执行**模式执行，即按照顺序从内存读取指令、译码、执行。这样一台计算机带有寄存器、逻辑运算单元（ALU）、存储器以及用来链接各个功能部件的总线。程序或者被保存在只读存储器中，或者由操作系统从硬盘加载到内存中。

寄存器是卫浴CPU内部的存储单元，类似与内存中的存储单元。寄存器使用名字而不是地址来访问。这样，计算机指令的操作码就可以使用很少的几位来引用寄存器；指令中用来选择寄存器的字段一般为3~5位，具体数值取决于计算机中程序可见寄存器的个数。

CPU中的寄存器有几个功能。一些寄存器是**高速暂存**寄存器，用于保存数据或者数据单元的地址（即指针）。另外一些则是特殊功能寄存器，比如对一个循环的次数进行计数的循环计数器，有的则用来记录处理器的状态。CPU中最重要的寄存器是**程序计数器（PC）**，它记录了要执行的下一条指令的地址；也就是说，程序计数器保持对程序执行的跟踪。有时PC也叫**指令指针**，这更反映出它的功能。

计算机指令有多种格式。为方便起见，假设通用计算机提供了以下3种指令格式：  
**LDR**	**寄存器**目的，存储单元源  
**STR**	寄存器源，**存储单元**目的  
**Opertation**	**寄存器**目的，寄存器源1，寄存器源2

LDR指令把数据从存储器复制到寄存器，而STR指令则执行相反的操作，即把数据从寄存器传输到存储器。

第三种指令类型带有3个操作数，每个操作数都引用了一个寄存器。指令中的操作码部分被表示为operation，它定义了CPU完成的操作（例如ADD、SUB、AND）。操作码后面的3个**操作数字段**指定了参与操作的寄存器。**源**操作数指明了数据的来源，**目的**操作数指明了结果存放在哪里。

中央处理单元（CPU）包括了算逻运算单元（ALU）、寄存器和总线。CPU中还包括控制单元，它是一个硬件子系统，负责取指、译码，并根据译码得到的信息来控制数据在寄存器和功能单元之间的流动，它也是一个输入/输出接口。

寄存器定义如下：  
MAR	存储器地址寄存器，保存了读或者写操作正在访问的存储单元的地址。  
MBR	存储器数据寄存器，保存了刚从存储器中读出的数据，或将写入存储器的数据。  
PC	程序计数器，保存了要执行的下一条指令的地址。因此，PC指向存放了下一条指令的存储单元。  
IR	指令寄存器，存放最近从存储器中读出的指令。也就是当前正在执行的指令。  
r0-r7	寄存器文件，包括8个通用目的寄存器r0,r1,r2,...,r7，用于存放临时（工作）数据（例如计算的中间结果）。一台计算机至少需要一个通用寄存器。我们的简单计算机中有8个通用寄存器。 

除寄存器外，计算机中还带有用来在寄存器之间以及寄存器与算逻运算单元之间传送信息的总线。ALU通过单操作数运算（单值或一元运算）或者双操作数运算（双值或二元运算）对数据进行处理。一元运算的典型例子有取负、递增、清除；二元运算的典型例子有与（AND）以及异或（XOR）等逻辑运算。

控制单元（CU）将解释执行指令寄存器（IR）中的指令；也就是说，它使得指令操作码所指定的指令被执行。它利用时钟脉冲流和操作码生成控制计算机总线、存储器、寄存器与功能单元的信号。

**地址**就是存储器中一个字位置的二进制表示。处理器采用寄存器-寄存器型体系结构，在执行一条形如ADD r1,r2,r3的指令时需要3个寄存器地址。当计算机在寄存器与存储器之间传递数据时需要两个操作数：寄存器和存储单元地址。

下述RTL记号表明了处理器如何读出并执行指令LDR　r1,1234的。  
```
FETCH	[MAR] <- [PC]					;把PC的值复制到存储器地址寄存器
			[PC] <- [PC]+4				;PC递增，指向下一条指令
			[MBR] <- [[MAR]]			;读出地址为MAR的指令
			[IR] <- [MBR]					;将指令从MBR复制到IR

LDR		[MAR] <- [IR(地址)]		 ;把IR中的操作数地址复制到MAR
			[MBR] <- [[MAR]]			;将地址为MAR的操作数读到MBR中
			[r1] <- [MBR]					;把操作数移到寄存器r1
```
[MAR] <- [PC]	程序计数器，包含下一条要执行的指令的地址，它被复制到存储器地址寄存器中，用来访问存储器，读出要被执行的指令。
[PC] <- [PC]+4	程序计数器加4，即指向下一条要执行的指令。指令按照顺序执行，除法有流控制指令改变了原来的顺序。增量为4而不是1是因为ARM指令长为4个字节。
[MBR] <- [[MAR]]	MAR(存储地址)所指的存储单元的内容被复制到存储器数据寄存器（MBR）中。因为MAR包含要执行的下一条指令的地址，MBR则存放了当前指令的操作码。符号[[MAR]]表示地址存放在MAR中的存储单元的内容。  
[IR] <- [MBR]	将存储器数据寄存器的内容复制到指令寄存器IR中。现在IR中存放了要执行的指令。控制单元用指令中的位生成实现该指令所需的控制信号。 

##### （1）常量处理

**立即数**是一个在运算中可以直接使用的数，与存储单元的值完全不同，需要用哈希符号（#）前缀来声明。

##### （2）流控制

**流控制**是指任意能够改变程序中指令顺序执行的动作。换句话说，它是指计算机非顺序执行指令的能力。通常，流控制是指转移到程序中特定位置的分支和跳转指令、子程序/过程调用，返回、中断以及操作系统调用。必须强调的是，流控制是反映计算机做出决策并在多个动作序列间选择的能力的关键因素，这一点十分重要。

流控制的典型例子就是条件行为，它允许处理器在两个可能的动作序列中选择一个执行。计算机通过测试一个操作的结果，然后执行程序中两条路径中的一条来实现条件行为；也就是说，测试结果决定了要将两个不同地址中的哪一个加载到程序计数器中。相应地，存储器将会从两个可能候选指令中读出一个，并将其加载到指令寄存器中。

实现条件控制的信息通路将ALU与程序计数器PC连接在一起，并允许ALU决定接下来要执行两个可选指令中的哪一个。决定分支转移（不转移）的条件就是ALU所执行的操作的结果。ALU的信息将被写入条件码寄存器（CCR），他保存了各种用于测试的条件（如，零、负、正）。也就是说，当ALU执行一个操作时，它会更新CCR中的零位、借位位、负位以及溢出位。

寄存器CCR与控制单元相连。控制单元负责指令译码，并生成必要的控制信号以执行指令。当BEQ等条件分支指令执行时，控制单元从CCR中选择所需的条件位并进行测试。如果测试的条件位为false，则CPU按照正常顺序执行下一条指令。如果测试的条件为true，则CPU就会跳到条件指令分支字段所指定的地址处，该地址被称作**分支目标地址**。

BPL Error（正则跳转）是一条典型条件的指令，如果前一个操作的结果为正，它会跳转到标号为“Error”的代码区域。指令寄存器中的**地址字段**与**程序计数器**之间的地址总线允许将一个**非顺序**地址加载到程序计数器PC中。

**状态信息**	下面进一步分析条件分支是如何实现的。计算机执行一个操作时，它将状态或者条件信息保存在CCR中。处理器记录下结果是否为0，结果的二进制形式是否为负，是否产生进位位，或者是否算术溢出。CCR中的位会在每一次操作后被更新，这一说法并不完全准确。实际情况非常复杂，一个处理器与另外一个处理器的情况完全不同。

**分支指令例子**	下面将说明如何使用条件分支指令BEQ address来实现高级语言结构。首先，处理器用IR中BEQ指令的操作码字段选出CCR中的一位进行测试。如果被测试的位为1，则PC会载入一个新地址，否则PC不变。

### 2.ISA的组成

在详细介绍真正的微处理器之前，必须介绍一下ISA的３个组成部分：寄存器集、寻址方式和指令格式。它们共同定义了汇编语言程序员看待处理器的视角。实际上由两个汇编语言程序员：**人和编译器**。

##### （1）寄存器

从概念上来看，寄存器是计算机中最没用的一部分。它甚至是没有必要的，也不参与任何计算。实际上，20世纪70年代的有些微处理器根本没有片上寄存器；它仅仅是用一组存储单元作为寄存器。片内的一个指针寄存器保存了存储器中寄存器的地址。然而，寄存器对于提高计算机性能和实际指令集设计是很有必要的。

实际计算机用寄存器实现片上存储，寄存器的功能与存储单元一样，唯一的区别在于访问的便捷性和响应时间。仅需很少的指令位就可以指定一个片上寄存器。

由于计算机中只带有少量的片内寄存器，因此有必要通过将数据载入寄存器的指令和将寄存器中数据存入存储器的指令在内存和寄存器之间传递数据（前面已经使用过的LDR和STR操作）。所有数据处理操作都只能针对寄存器的内容，这类计算机叫作载入和存储计算机，它表明对存储器进行的操作只能是将数据传送到寄存器中或者从寄存器中取出数据。这些计算机总是被归于RISC一类。

寄存器的大小（它的位宽）通常等于计算机完成的数据处理操作的最大位宽。

有些计算机允许对寄存器的部分内容（子集）进行操作。一些寄存器将其内容作为二进制补码处理，对寄存器部分内容进行操作的结果被符号扩展到整个字。

###### 通用寄存器vs特殊功能寄存器

8086所用的IA32体系结构使用了一组特定的16位寄存器叫做AX、BX、CX和DX，每个寄存器可被分解为一对寄存器，用作字节寄存器。它还有4个变址（指针）寄存器和4个段寄存器。需要强调的是，8086的寄存器都是高度专用的，程序员必须记住每个寄存器都能做什么以及哪条指令使用哪个寄存器。

提供特殊功能寄存器意味着无需在指令字·中分配一些位去指明它的用途。使用专用寄存器会使代码更加紧凑，这在微处理器发展的早期是一个非常重要的特性，因为早期存储器的价格是现在的数百万倍。

Motorola，在8086之后不久研发了68K处理器。这是一个使用32位寄存器的32位处理器。它使用通用寄存器，包括8个数据寄存器D0~D7和8个地址（指针）寄存器A0~A7。所用寄存器都可以互换使用，当然，采用这种方法意味着所有基于寄存器的指令都需要3位寄存器选择字段以区分寄存器。

ARM由16个通用寄存器r0~r15。寄存器r0~r13可互换使用，行为相似。寄存器r14和r15还有额外的功能（r14为链接寄存器，保存子程序返回地址；r15为程序计数器）。尽管人们希望能自由地使用寄存器r13，但良好的编程实践却要求保存r13以使用栈指针。

##### （2）寻址方式概述

* 立即数寻址
* 直接寻址
* 间接寻址

前面已经见到过这些寻址方式。最简单的寻址形式是立即数寻址，其操作数是指令的一部分。由于它是指令的一部分，它没有被保存在存储单元或寄存器中，而成为指令的组成部分。立即数寻址意味着操作数为常数，它的值不能在程序执行过程中改变。

这种寻址方式也叫**立即寻址**，因为操作数立即可用。计算机也会使用立即数寻址来设置在程序执行过程中不会改变的常量。

第二种方法是**直接寻址**，也称绝对寻址。这种寻址方式是把操作数地址用作指令的一部分。Load-store型计算机，比如ARM，没有实现直接寻址。所有存储器操作数要么被指定为立即数，要么通过寄存器指针间间接指定。

第三种寻址方式有许多名称——本书中叫作**间接寻址**，或者更严格地说，叫作**寄存器间接寻址**。在寄存器间接寻址中，指令给出了包含操作数地址的寄存器的地址。获得一个操作数需要3次访问：读指令，读含有操作数地址的寄存器，以及最后读出实际的操作数。含有操作数地址的寄存器称作指针寄存器。Load-store型计算机使用这种寻址方式访问存储器操作数。

寄存器间接寻址对访问表格和数组非常有用，因为它可以操作指针寄存器访问数组元素。寄存器间接寻址有许多变种。最常用的格式是带偏移量的寄存器间接寻址，其中操作数的地址由寄存器内容加上常量或者偏移量指定。

这一寻址方式带有一个立即数常量，它在编写程序的时候就已经确定。带偏移量的寄存器间接寻址允许使用指针指向数据区的基地址，而用偏移量指明数组中给定的元素。

###### 存储器与寄存器寻址

前面已经指出，寄存器与存储单元之间没有本质区别。其区别主要体现在它们的相对访问速度以及指定一个寄存器和一个存储单元所需的地址位数上。在实践中，这意味着8位计算机时代计算机指令不能实现较长的存储器地址。若没有意外，一条指令只能提供一个存储器地址。

由此可以推出，这些计算机不支持存储器—存储器操作。因此，微处理器一般提供3种指令模式：

* **存储器—寄存器型**：源操作数在存储器中，目的操作数在寄存器中；
* **寄存器—存储器型**：源操作数在寄存器中，目的操作数在存储器中；
* **寄存器—寄存器型**：两个操作数都在寄存器中。

Freescale 68K确实支持存储器—存储器型操作（仅支持MOVE指令），这时源操作数和目的操作数都在内存中。这条指令长10个字节（80位），因为它需要16位指令字后跟两个32位的地址。

##### （3）指令格式

体系结构就是计算机指令本身，这是指令集的重点所在。指令指明了下一步要执行的操作。仅考虑指令长为一个字的情形，它指定了要执行的操作以及其他额外信息（即立即数、寄存器或地址）。

RISC计算机，比如ARM和MIPS，其指令受到了严格限制；指令长度必须规整为一个字。因此，指令集设计者受到指令字长的约束。CISC计算机通过允许指令长度扩展为几个字解决了固定指令长度的问题。

计算机设计的历史中充斥着各种试图打破这一约束的尝试，即 *操作码位数* + *操作数位数*  = *计算机字长*。前面曾说到过立即数的范围为0~900。使用一个10位的字段可以编码范围为0~1023内的立即数。因此，从901~1023之间的123个立即值可以分配给新的指令。当然，这些新指令只能完成那些不需要立即数的操作。如果说“天下没有免费的午餐”，那么在指令集设计的领域也是如此。

##### （4）操作码与指令

可以用几种方法将指令分组或分类。计算机体系结构设计中最重要的一个因素是每条指令中操作数地址的数量。例如，实现了指令ADD r1，r2，r3的指令集是*三地址*计算机，而实现了ADD，r1，r2指令的计算机是*双地址*的。也可以按照操作的性质来将指令分组。例如，*数据移动*指令把数据从一个地方移到另一个地方；*数据处理*指令进行数据运算，而*流控制*指令修改指令执行的顺序。

###### 双地址计算机

CISC计算机采用*双地址*指令格式。明确的说，不能仅用两个操作数就完成指令P = Q＋R。但可以执行操作Q<- P + Q。有个操作数出现了两次：第一次为源操作数，第二次作为目的操作数。操作ADD P，Q执行运算[Q] <- [P] + [Q]。双操作数指令格式的代价是一个源操作数的内容会因为覆写而遭到破坏。绝大多数计算机指令不能直接访问两个存储单元。典型情况下，操作数要么是两个寄存器，要么是一个寄存器和一个存储单元。

###### 单地址计算机

单地址计算机在指令中仅指定了一个操作数。第二个操作数是一个叫*累加器*的固定寄存器，它无需指定。

八位计算机采用单地址结构。可以想象，8位代码是很冗长的，因为必须将数据加载到累加器进行处理，然后把结果存放起来以避免被下一条数据处理指令覆盖。目前单地址计算机仍被广泛地应用于超低功耗、低性能的系统中。

###### 零地址计算机

零地址计算机使用根本没有地址的指令。零地址计算机对位于栈顶的数据进行处理，因此通常也被称作*栈计算机*。当然，一个纯粹的零地址计算机是不实用的。需要通过load和store指令从存储器中读出数据或把数据保存到存储器中。

单操作数运算（一元运算，如取负、清零、递增、递减）作用于栈顶数据，而双操作数运算（二元运算，如加、乘、逻辑或）首先从栈顶取出两个元素，进行运算，然后将结果入栈。将一个数据放到栈顶的操作叫作入栈（PUSH），而从栈顶取出一个数据的操作叫作出栈（POP）。

除了常规数据处理运算外，零地址计算机也包括使堆栈编程更加方便地数据控制运算。例如，支持栈顶数据复制或者栈顶两个数据项交换的指令。

高级语言Java被编译成一种低级的基于栈的语言，叫作**字节码**，并在真实计算机上解释执行。有些ARM处理器集成了Jazelle直接字节码执行，能够直接执行字节码。由硬件直接执行字节码提高了ARM运行Java应用时的性能。

###### 一个半地址计算机

Intel IA32系列与Freescale系列通常叫作**一个半地址**计算机，这是因为它们的指令指定了两个操作数，一个操作数是存储器地址，另外一个操作数则是寄存器地址。寄存器地址被讽刺地称为半个地址，因为与GB量级的存储空间相比，寄存器的数量很少。

### 3.ARM指令集体系结构

##### （1）ARM寄存器集

ARM共有14个通用寄存器r0~r13。寄存器r14存放子程序返回地址，r15为程序计数器。由于r15能够被程序员所访问，因此能够执行可以计算的分支。ARM仅有16个通用寄存器，作为一个RISC处理器还是很少见的。16个寄存器需要4位地址，相对于带有32个寄存器的RISC处理器来说每条指令可节约3位。这种方法使得ARM的指令比一些RISC处理器丰富得多。寄存器r13被保留用作栈指针。与特殊功能寄存器r14和r15不同，它们的附加功能由ARM的硬件实现，仅当程序员需要使用r13作为栈指针时它才会成为栈指针。

ARM的**当前处理器状态寄存器（CPSR）**包括Z（零）、N（负）、C（进位）和V（溢出）等标志位，类似于其他处理器中的条件码或状态寄存器。



##### （2）ARM指令集

| 指令 |  ARM助记符   |             RTL定义 |
| :---: | :----------: | :------------------: |
| 加法 | ADD r0,r1,r2 | [r0] <- [r1] + [r2] |
| 减法 |SUB r0,r1,r2 | [r0] <- [r1] - [r2]|
|与| AND r0,r1,r2|[r0] <- [r1] · [r2] |
|或|ORR r0,r1,r2|[r0] <- [r1] + [r2]|
|异或|EOR r0,r1,r2|[r0] <- [r1] &oplus; [r2] |
|乘|MUL r0,r1,r2|[r0] <- [r1] x [r2]|
|寄存器—寄存器移动|MOV r0,r1|[r0]<-[r1]|
|比较|CMP r1,r2|[r1]-[r2]|
|相等跳转|BEQ label|[PC] <- label(跳转到label处)|

### 4.ARM汇编语言

汇编程序由两部分语句组成：计算机**可执行指令**和告诉汇编器运行环境有关信息的**汇编伪指令**。汇编伪指令告诉汇编器代码在存储器中的位置，为变量分配存储空间，以及设置程序运行时所需的初始数据。

##### （1）汇编器的实际考虑因素

EQU和DCD是两个重要的汇编伪指令，EQU把一个名字与一个值绑在一起，DCD在程序运行前将数据提前载入存储空间。伪指令EQU很容易理解。它把一个数字值绑定（即附加）到一个名字上。

汇编语言程序可以使用常量、变量和数据结构。它们都被存储在存储器中的某些位置。计算机用户从来不必关注这些，因为操作系统和系统软件会自动为数据分配存储空间。高级语言程序员一般通过变量或常量声明来分配存储空间。

助记符DCD在存储器中预留一个32位字的存储空间，并且把它右边表达式的值加载到该存储单元中。

位置计数器按4字节递增，这样下一个DCD或指令将会保存到下一个字存储单元中。术语“位置计数器”是指在程序进行汇编时指向下一个存储单元的指针，它在概念上类似于程序计数器。

**魔术代码：** 它是运行环境或操作系统的功能。

##### （2）伪指令

下面介绍伪指令，它是程序员可用的指令，但不是处理器ISA的一部分。伪指令是一种速记形式，程序员可以用它简单地表示一个动作，并使汇编器生成合适的代码。

**ADR**是ARM最有用的指令之一，它把地址加载到目的寄存器中。该指令的格式为 ADR $r_{destination}$,label，这里label是程序中有效地址的标号。尽管我们会在程序中看到ADR，但它并不是一个真正的指令，因为没有指令能把32位常量加载到ARM寄存器中。ADR是一个可由程序员使用的伪操作或虚拟指令，之后汇编器将生成能完成同样功能的实际机器代码。伪指令是一种便捷的形式，汇编器将其转换为实际指令，将除程序员从一些事务性工作解脱出来。一般来说，ADR能够利用ARM的ADD或SUB指令以及PC**相对寻址方式**产生所需要的地址。

另一个很有用的伪指令是 LDR rd， = value。在这个例子中，编译器会生成将已知值载入寄存器rd中的代码。

### 5.ARM数据处理指令

##### （1）算术指令

###### 加法与减法

除了将两个字相加的“一般化操作”以外，绝大多数微处理器都实现了带进位的加法指令，能够将两个操作数和条件码寄存器中的进位位加到一起。这条指令会使字长大于计算机固有字长的链接运算更加方便。

首先使用指令ADDS r4,r0,r2,完成r0 + r2并将结果保存到r4中。进位输出保存到CCR的进位位中（ADD后添加了后缀s以强制更新进位位）。当使用指令ADC r5，r1，r3将高位的两个数字相加时，进位位也被加到r1与r3的和中。助记符ADC表示带进位的加法。这一原理可被推广到完成任意长整数的扩展精度算术运算。

ARM提供了一种不常用的逆减法指令RSB。减法指令SUB  r1，r2，r3被定义为[r1] <- [r2] - [r3]，而逆减法指令RSB  r1，r3，r2可以实现[r3] - [r2]。然而，由于ARM认为两个操作数是不平等的，所以逆减法指令还是有用的。

###### 取负

取负就是用零去减去一个数字。

**取反传送**是ARM提供的另一种有趣但不常用的操作。例如，NVN  r0，r1将寄存器r1的值**逻辑取反**后再复制到寄存器r0中。这个操作实现了逻辑取反（按位取反），而不是算术取反（符号反转）。

###### 比较

实现条件操作所必须的比较运算可分为隐式和显示两种。隐式比较在执行指令 SUBS r1，r1，#1时发生，因为r1减去1后，若结果位0则CCR中的Z位会被置为１.

通过执行指令ＣＭＰ	Q，Ｐ比较P和Q时将发生显示比较，这条指令会计算Q－Ｐ但不会保存结果。

###### 乘法

ARM的乘法指令MUL Rd，Rm，Rs计算保存在32位寄存器Rm和Rs中的两个32位有符号数的积，然后将结果保存在32位寄存器Rd中，仅存放64位积的低32位。当然，应保证结果不超出范围。

不幸的是，目的寄存器Rd和源寄存器Rm不能使用相同的寄存器，因为ARM在乘法计算过程中将Rd当作临时寄存器使用。这是ARM处理器的一个特定。

ARM有一个乘累加指令，它先进行乘法，然后将乘积与另一个数相加。MLA指令采用四操作数形式：MLA Rd，Rm，Rs，Rn，它的RTL定义为[Rd] <- [Rm] x [Rs] + [Rn]。32位数与32位数的乘积被截断成低32位结果 。

###### 除法

除法操作面临着与乘法一样的问题：一个2m位数除以一个m位数会得到商和余数。同样，有符号和无符号除法需要两个独立的除法指令。ARM没有实现除法运算，程序员必须自己编写软件除法子程序。

##### （2）位操作

逻辑操作也叫位操作，因为这些操作被应用到寄存器的每一位。尽管对两个布尔变量一共有16个可能的逻辑操作，但微处理器一般只支持AND、OR、NOT和EOR或操作。

逻辑运算的典型应用就是数据合并，即把多个变量合并到一个寄存器或存储单元中。

ARM提供了位清除指令BIC，将第一个操作数与第二个操作数的反码进行与操作。例如，BIC r0，r1，r2实现了 [r0] <- [r1] · [$\overline{r2}$]。如果BIC第二个操作数中某位为0，则它将第一个操作数中对应的位复制到目的操作数中；如果第二个操作数中某位为1，则把目的操作数中对应的位清零。

##### （3）移位操作

移位操作就是把字中的位向左或向右移动一个或多个位置。然而，当移位一个位串时，串一端的位会被丢弃，并在另外一端补充新的位。

所有微处理器都支持逻辑移位操作。有些支持向左或向右移动一位，其他的支持多位移移位。如果移位的位数在指令中被编码位**常量**，这种移位叫作**静态移位**，因为在运行时不能改变移位位数。如果移位的位数由**寄存器的值**指定，则叫作**动态移位**，因为可以在程序运行时修改移位的位数。

###### 算术移位

算术移位将操作数视作一个有符号二进制补码数，可以用来完成除以2或者乘以2等运算。算术移位的目的时在进行移位运算时保留二进制补码数的符号，移位运算代表乘以或除以2的幂。

**算术左移**与**逻辑左移**是等价的。算术右移会保留符号，每次右移后符号位会自动复制。一个整数算术左移m位相当于乘以$2^m$，而它算术右移m位则相当于除以整数$2^m$。

###### 循环移位

循环操作把寄存器的内容看作一个LSB于MSB相邻的环，当进行移位时，从一端移出去的位会从另一端移进来。与逻辑移位和算术移位相比，循环操作不丢失位。移出的位也被复制到进位寄存器。微处理器一般采用这种方法，这样就可以根据移出的位进行条件操作。

有些处理器实现了另一种循环操作，叫作**扩展循环移位**或**带进位的循环移位**。这个操作与循环操作一样，只不过循环时包含了进位位。移出的位被复制到进位位，原来的进位位被被变成了被移入的位。这个操作被用于链接运算。

###### ARM移位操作的实现

ARM实现移位操作的方法非常独特，它没有独立的移位操作。实际上，移位操作与其他数据处理操作组合到一起，这是因为可以在使用第二个源操作数之前将其移位。

如果仅希望对寄存器进行移位操作，而不需要进行其他数据处理，则可以使用下面的数据传送指令，

MOV r3，r3， LSL #1

由于可完成动态移位，也可使用指令MOV r4，r3，LSL r1，它以r1为移位位数对r3进行移位，然后把结果送入r4。

除了仅允许移动一位RRX指令外，ARM支持静态和动态移位。静态移位在编程时就已经确定了移位的位数，而动态移位则允许在执行代码时改变移位位数。

ARM仅实现了以下5种移位操作：

- LSL	逻辑左移

- LSR	逻辑右移

- ASR	算术右移

- ROR	循环右移

- RRX	带进位的循环右移（移位一次）

尽管没有循环左移操作，但借助循环右移也可轻而易举地实现它。经过4次循环移位，操作数没有发生变化。循环左移和循环右移是对称的。对于32位数，循环左移n位等价于循环右移32-n位。

ARM也没有实现带进位的循环左移操作。但通过指令ADCS r0,r0,r0也可实现带进位的循环左移。这看起来似乎很奇怪，因为它把r0与r0以及进位位一起相加，并将结果保存到r0种。现在请考虑带进位的循环左移。左移等价于乘以2。而把进位位移动到最低位等价于加上进位位，这样可以得到2 x [r0] + C。请注意指令后加了S会强制更新CCR，这可以确保进位输出被加载到C位。因此，ADCS r0,r0,r0与 RXL r0是等价的。

### 6.ARM的流控制指令

计算机按照严格的顺序执行指令。流控制改变了默认的顺序执行方式。**调用**和**返回**指令会通过跳转到一个指令块、执行这些指令、然后返回到子程序调用指令后的一个位置来修改控制流。

##### （1）无条件分支

ARM无条件分支指令的格式为B target，这里target指分支**目标地址**，也就是要执行的下一条指令的地址。

无条件分支并不是一个令人兴奋的指令。人们总是在执行了程序中一段特别的路径之后用它返回到某个公共位置。无条件分支实际上就是“返回”指令。

##### （2）条件分支

ARM的条件分支与其他RISC和CISC处理器的类似。包括助记符$B_{cc}$和一个目标地址，这里下标定义了转移成功时必须满足的16个条件之一，而目标地址就是分支转移成功时要继续执行的代码的地址。

分支指令可以使用**有符号**数据或**无符号**数据。有些微处理器对于一些条件分支操作会有同义词；也就是说，同一个条件分支指令由两个助记符。

##### （3）测试与比较指令

ARM有4条测试与比较指令（CMP、CPN、TST、TEQ）。这些指令会**显式**地更新条件码标志，因此无须在指令后添加S。

- **相等测试**指令（TEQ）确定两个操作数是否相等。如果相等则将Z位置1，否则将Z位清0。

- **测试**指令（TST）通过与操作来比较两个操作数，然后根据测试结果更新标志位。可以用TST来测试一个字中的每一位。
- ARM的**比较**指令用第一个源操作数减去第二个，然后更新条件码。
- **取负并比较**指令CMN在进行比较操作之前先将第二个源操作数取负。

##### （4）分支与循环结构

用经典的循环结构来介绍流控制概念时最合适的，循环时结构化编程的核心。下面代码说明了FOR、WHILE、和UNTIL循环的结构。


1.FOR循环循环开始执行测试
```
		MOV	r0,#10		;设置循环计数器
Loop	code...			;循环体
		SUBS r0,r0,#1	;循环计数器减1并设置状态标志
		BNE	Loop		;继续直到计数值位零——不为零时跳转
		Post Loop...		;计数值为零的后续代码
```
2.WHILE循环
```
Loop		CMP r0,#0		;循环开始执行测试
			BEQ WhileExit	;测试结果为true则退出
			code...			;循环体
			B	Loop		;为true时重复
WhileExit	Psot Loop		;退出
```
3.UNTIL循环
```
Loop	code...			;循环体
		CMP		r0,#0	;循环末尾进行测试
		BNE 	Loop	;重复直到UNTIL为true
		Post	Loop...	;退出
```

4.组合循环

组合循环将上面3种循环的特点结合在一起。FOR部分指定了最大计数值，限制了循环的执行次数。WHILE部分测试r1中的初始条件，如果不为true则立刻退出。UNTIL部分则在循环体末尾r2为true时退出。

```
			MOV	r0,#10		;设置循环计数器
LoopStart	CMP	r1,#0		;以WHILE测试开始
			BEQ ComboExit	;为true退出循环
			Code...			;循环体
			CMP	r2,#0		;测试UNTIL条件
			BEQ	ComboExit	;为true退出循环
			SUBS r0,r0,#1	;循环计数器减1并设置状态标志
			BNE LoopStart	;继续直到计数器为零——不为零则转移
ComboExit	Post loop...	;退出
```

##### （5）条件执行

ARM最不寻常的特点之一就是每条指令都是**条件执行**的。可将指令与逻辑条件关联在一起。当指令准备执行时，如果所述条件为真，则指令正常执行；否则指令会被旁路（无效或转换为空操作）。到目前，所有ARM指令都是正常执行的，因为我们总是将指令与缺省条件“总是执行”关联在一起。

除了缺省条件为“总是执行（AL）”，另一个特殊条件是“从不执行（NV）”，ARM将其保留用作未来的扩展。汇编语言程序员在指令助记符后添加合适的条件以指明条件执行模式。例如，助记符

ADDEQ	r1，r2，r3

指定仅当条件码寄存器中的Z位因为前一个结果为0而被置为1时，加法操作才会被执行。

### 7.ARM寻址方式

**寻址方式**指的是确定操作数位置的方式。本章开始介绍的简单体系结构计算机支持**绝对寻址**和**立即数寻址**方式，讨论ARM的加载（load）与存储（store）指令时，还引入了**寄存器间接**寻址方式。

##### （1）立即数寻址

###### ARM的实现方法

ARM实现立即数的方法与IA32、68K或MIPS等其他处理器完全不同。实际上，ARM提供的是可按照**2的幂缩放**的8位立即数。甚至可以认为ARM提供了某种浮点立即数。ARM立即操作数的编码结构。当操作码的第25位为0时，ARM将进行一次移位操作。当第25位为1时，操作数2字段将编码12位立即数，它被分为两个部分：8位立即数和4位对齐码。

立即数字段中最高4位指定了立即数在32位字中的对齐方式。如果8位立即数为N，4位对齐码为n（范围在0~12之间），则立即数的值为$N \ast 2^{2n}$。因此，ARM提供了一个一个可按照2的幂缩放的8位立即数。当然，这与浮点数的表示和存储方法相似。

##### （2）寄存器间接寻址

前面已经遇到过这种寻址方式，即操作数的地址保存在寄存器里。这种寻址方式叫作**寄存器间接寻址**，因为指定的寄存器是指向实际操作数的指针。在ARM文献里，这种寻址方式也叫**索引（变址）寻址**，有些人也把它叫作**基址寻址**。寄存器间接寻址方式需要通过3个读操作来访问一个操作数：

- 读指令得到指针寄存器
- 读指针寄存器得到操作数地址
- 读操作数地址所指的存储单元得到操作数。

寄存器间接寻址非常重要，因为可以在运行时修改寄存器的内容，而寄存器中含有指向实际操作数的指针，因此地址是变量，允许访问如数组、列表、矩阵、向量和表格等数据结构。

有些计算机将寄存器间接寻址与**指针更新**结合在一起，这样指针在被使用过之后就可以自动地指向下一个存储单元。

##### （3）带偏移量的寄存器间接寻址

ARM支持一种存储器寻址方式，即操作数**有效地址**是**寄存器**的内容加上编码在load/store指令的**立即数偏移量**。这种寻址方式经常也叫**基址加位移寻址**。ARM的立即数偏移量为12位。它确实是12位立即数，不是8位可缩放的值。

可以使用这种寻址方式实现绝对寻址。然而，由于偏移量为8位可缩放的常数，这样的绝对寻址并不是一个很有用的技巧。

ARM允许指定第二个寄存器作为偏移量，这样就可以使用运行时可以修改的动态偏移量。

前面已经说明可以通过向基址寄存器加立即数偏移量或寄存器偏移量来扩展寄存器间接寻址方式。在ARM术语中，**基址寄存器加偏移量**的寻址方式叫作**前索引**，因为是在访问操作数之前把偏移量加到指针上。

##### （4）ARM的自动前索引寻址方式

ARM在寄存器间接寻址期间自动修改索引或基址寄存器的内容，这有助于读取向量、表格和数组等结构中的有序数据。这种寻址方式可用不同的术语来描述。例如，使用术语**自动递增**和**自动递减**来强调指针的自动修改，**前索引**和**后索引**则强调什么时候递增。

由于数组、表格或类似数据结构中的元素经常被顺序访问，ISA设计者就实现了自动索引寻址方式，指针寄存器在使用之前或之后就被自动的调整为下一个元素。通过将偏移量加到基址寄存器（指针寄存器）上ARM实现了两种自动索引方式。这两种方式的差别在于基址寄存器递增的时机——要么在访问存储器之前，要么在之后。

ARM的**自动前索引**寻址方式是在有效地址后面添加后缀！来表示。

**自动索引**方式不会带来额外的执行时间，因为它与存储器访问并行完成。

每一次执行指令```LDR r3,[r0,#4]!```时，从地址为r0+4的存储单元中取出操作数，然后r0的值加4指向下一个元素，为下一次循环做好准备。前面已经将指针设置为每个数组首地址减4个字节，因为指针是在使用前递增的。幸运的是，汇编器允许指令```ADR r0,A-4```（即汇编器在汇编指令之前产生A的地址并用该地址减去4）。

##### （5）ARM的自动后索引寻址方式

ARM也提供自动**后索引**寻址方式，它首先访问基址寄存器所指的存储单元中的操作数，然后将基址寄存器递增。

后索引把偏移量放在中括号的外面（例如[r1],#8)。该指令的RTL定义为：

```
[r0] <- [[r+1]]		访问基址寄存器r1所指存储单元
[r1] <- [r1]+8		加上偏移量更新指针（基址寄存器）
```

##### （6）程序计数器相对寻址

任何一个ARM寄存器可用于实现寄存器间接寻址。然而，寄存器r15不仅仅是任何一个寄存器，它还是程序计数器。如果把r15用作访问操作数的指针寄存器，这种寻址方式叫作**程序计数器（PC）相对寻址**，操作数地址由其与当前代码的相对位置确定。这意味着可以将代码及与之相关的数据移动到存储器中的不同地方，而无需重新计算操作数地址。

##### （7）ARM的load与store指令编码

ARM的load和store指令的格式。访存操作有一个条件执行字段，即操作码的第28~31位，它们可以像其他ARM指令一样条件执行。

操作码第20位选择数据传送的方向；即指令是load还是store。第25位（#位）决定了偏移量是带可选移位的寄存器内容还是12位常量。第22位选择操作数大小，并确定ARM是传送32位字还是8位字节。当字节被加载到32位寄存器中时，寄存器的第8~31位将被置为零（即字节不会被符号扩展）。

### 8.子程序调用与返回

子程序是一个能够被调用和执行，然后返回到调用点那条指令的代码段。严格地说，子程序是一个能够被调用和执行的代码块，而**函数**会被调用并返回参数。而且，当调用子程序时，可以在调用者与子程序之间传递参数。

##### （1）ARM对子程序的支持

ARM的**分支并链接**指令BL，自动将返回地址保存在寄存器r14中。分支指令的格式中带有一个8位操作码和24位由符号的相对程序计数器的偏移量。由于分支目标地址是一个字地址，分支地址按32位字边界对齐，因此，它首先将24位偏移量左移两位，把字偏移地址转换成字节地址；然后26位字节地址被符号扩展为32位，并被加到程序计数器上。由于分支地址偏移量为26位（即24+2），因此条件分支的寻址范围为PC &plusmn;32M字节。

分支并链接指令的行为与对应的分支指令基本相同，但它会将返回地址（即调用指令后的下一条执行指令的地址）复制到链接寄存器r14。如果执行：

```
BL		Sub_A		;带链接跳到Sub_A
					;保存返回地址到r14
```

ARM执行了分支指令，将跳转到标号Sub_A指定的目标地址处。它还会将寄存器r15中的程序计数器复制到链接寄存器r14中，以保存返回地址。子程序的末尾通过把r14中保存的返回地址传送到程序计数器中，其返回子程序。

把代码块转换成子程序所要做的唯一事情就是设置入口点（标为“Func1”）和返回点，用于恢复BL保存在链接寄存器中的地址。

### 9.子程序与栈

现在介绍栈如何支持子程序调用和返回结构，以及ARM的栈处理指令。栈是一种数据结构，一个**后进先出**的队列，数据从一端进入，以相反次序离开。微处理器中的栈由**栈指针**指向存储器中的栈顶来实现。当数据项添加到栈里时，栈指针向上移动；当数据项从栈里移出时，栈指针向下移动。

实现栈时需要做出的两个决定：一是当数据项进栈时栈是向**低地址方向向上生长**还是**向高位地址方向向下生长**；另外一个决定是栈指针指向当前位于栈顶的数据项还是指向栈顶上的第一个空白位置。栈的实际排列不重要；最重要的问题是行为必须一致。设计栈的实际问题是用于将数据入栈的寻址方式是自动递增的还是自动递减的，栈调整是在数据进栈之前还是之后。

##### （1）子程序调用与返回

可以通过先将返回地址入栈，然后跳转到分支目标地址处来实现子程序调用。

##### （2）子程序嵌套

栈的一个重要特性就是它支持**嵌套子程序**，即其中一个子程序可以调用其他的子程序。当一个子程序完整地嵌入到另外一个子程序中时（即，如果调用一个子程序，总是立即返回到调用点后下一条指令），子程序就是嵌套的从一个点调用子程序，而从子程序返回到一个完全不同的点，这被认为是一个很差的编程习惯。

##### （3）叶子程序

ARM文献中经常提及**叶子程序**。叶子程序不调用其他子程序（即它们处于树的末端）。当对带有通用栈结构与子程序调用和返回指令的CISC处理器进行编程时，不必担心返回地址。RISC处理器没有对子程序调用与返回提供直接的栈支持，这迫使程序员必须了解这一细微的差别。

如果使用BL指令调用一个叶子程序，则返回地址将保存到链接寄存器r14而不是栈中。返回到调用点由指令     MOV pc，lr实现。然而，如果该子程序不是叶子程序，不保存链接寄存器就不能调用其他子程序。

### 10.数据的大小与排列

##### （1）数据组织与端格式

一般认为数据在存储器中的存储方式是一个无关紧要的问题（即只要一个接一个地将数据保存起来就可以）。然而，位和字节的编号方法会引起使用不同方法存储数据的处理器系列之间的不兼容。

字编号是通用的，所有计算机都把存储器中第一个字节编号为字0，最后一个字编号为$2^{n-1}$。然而 处理器之间的**位编号**是不同的。类似于人们将数字的最低位写在右边。绝大多数微处理器都采用同样方法，从字的最低位，就是第0位，到最高位，就是第m-1位，对字中的各位进行编号。

与字节中位的组织方法一样，人们必须考虑字中各字节的组织方法。可以使用两种方法对字中的字节编号。要么将最高字节放在字的**最高位字节地址**处，要么将最高字节放在字的**最低位字节地址**处。如果将最高字节放在最低地址，这种顺序叫作**大端格式**；如果将最高字节据放在最高字节地址，这种顺序叫作就是**小端格式**。

ARM也有**将块移动到存储器**的指令STM与从**存储器移出块**的指令LDM，它们能够在寄存器组和存储器之间拷贝块。这两条块移动指令用两个后缀描述了如何访问指令。

从概念上来说，块移动很容易理解，要么是“将这些寄存器的内容复制到存储器”，要么相反。而在实践中却很复杂，因为ARM提供了一整套选项以确定如何进行移动（例如寄存器是从高地址移到低地址还是从低地址移到高地址，存储指针更新是在传输之前还是在传输之后）。

```
STMIA r0!,{r1-r3,r5}	;请注意语法，需要进行移动的寄存器放在大括号里
```

该指令将寄存器r1~r3以及r5复制到地址连续的存储单元中，它用r0作为带自动索引的指针。后缀IA表面索引寄存器r0将在每一次数据传输后**递增**，从而使地址变大。尽管ARM的块模式指令有几种不同形式，但ARM**总是把编号最低的寄存器存储到地址最低的位置**，接着就是把编号次低的寄存器保存到次低地址，等等。

###### 块移动与栈操作

如前所述，ARM块移动指令形式多样，因为它支持4种可能的模式。这些模式之间的区别是栈生长的方向（向上或上升以及向下或下降）以及栈指针是指向栈顶的数据还是指向栈顶的下一个空位置。

ARM文献用4个术语描述栈：

- FD  满下降
- FA   满上升
- ED  空下降
- EA  空上升

请注意ARM分别用术语上升和下降描述栈朝高地址或低地址生长，而不是指在页面向上或向下生长，这十分重要。如果栈指针向栈顶元素，则这个栈被称为**满的**。如果栈指针指向栈顶之上的一个空元素，则这个栈被称为空的。

###### 块移动指令的应用

ARM块移动指令最重要的应用之一是在进入子程序时保存寄存器和从子程序返回时恢复寄存器。

