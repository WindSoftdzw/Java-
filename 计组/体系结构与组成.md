# 体系结构与组成


###### 2019/7/12

### 1.存储程序计算机

ARM这一类处理器采用了存储程序体系结构，它将程序和数据放在同一个存储空间内，采用**取指-执行**模式执行，即按照顺序从内存读取指令、译码、执行。这样一台计算机带有寄存器、逻辑运算单元（ALU）、存储器以及用来链接各个功能部件的总线。程序或者被保存在只读存储器中，或者由操作系统从硬盘加载到内存中。

寄存器是卫浴CPU内部的存储单元，类似与内存中的存储单元。寄存器使用名字而不是地址来访问。这样，计算机指令的操作码就可以使用很少的几位来引用寄存器；指令中用来选择寄存器的字段一般为3~5位，具体数值取决于计算机中程序可见寄存器的个数。

CPU中的寄存器有几个功能。一些寄存器是**高速暂存**寄存器，用于保存数据或者数据单元的地址（即指针）。另外一些则是特殊功能寄存器，比如对一个循环的次数进行计数的循环计数器，有的则用来记录处理器的状态。CPU中最重要的寄存器是**程序计数器（PC）**，它记录了要执行的下一条指令的地址；也就是说，程序计数器保持对程序执行的跟踪。有时PC也叫**指令指针**，这更反映出它的功能。

计算机指令有多种格式。为方便起见，假设通用计算机提供了以下3种指令格式：  
**LDR**	**寄存器**目的，存储单元源  
**STR**	寄存器源，**存储单元**目的  
**Opertation**	**寄存器**目的，寄存器源1，寄存器源2

LDR指令把数据从存储器复制到寄存器，而STR指令则执行相反的操作，即把数据从寄存器传输到存储器。

第三种指令类型带有3个操作数，每个操作数都引用了一个寄存器。指令中的操作码部分被表示为operation，它定义了CPU完成的操作（例如ADD、SUB、AND）。操作码后面的3个**操作数字段**指定了参与操作的寄存器。**源**操作数指明了数据的来源，**目的**操作数指明了结果存放在哪里。

中央处理单元（CPU）包括了算逻运算单元（ALU）、寄存器和总线。CPU中还包括控制单元，它是一个硬件子系统，负责取指、译码，并根据译码得到的信息来控制数据在寄存器和功能单元之间的流动，它也是一个输入/输出接口。

寄存器定义如下：  
MAR	存储器地址寄存器，保存了读或者写操作正在访问的存储单元的地址。  
MBR	存储器数据寄存器，保存了刚从存储器中读出的数据，或将写入存储器的数据。  
PC	程序计数器，保存了要执行的下一条指令的地址。因此，PC指向存放了下一条指令的存储单元。  
IR	指令寄存器，存放最近从存储器中读出的指令。也就是当前正在执行的指令。  
r0-r7	寄存器文件，包括8个通用目的寄存器r0,r1,r2,...,r7，用于存放临时（工作）数据（例如计算的中间结果）。一台计算机至少需要一个通用寄存器。我们的简单计算机中有8个通用寄存器。 

除寄存器外，计算机中还带有用来在寄存器之间以及寄存器与算逻运算单元之间传送信息的总线。ALU通过单操作数运算（单值或一元运算）或者双操作数运算（双值或二元运算）对数据进行处理。一元运算的典型例子有取负、递增、清除；二元运算的典型例子有与（AND）以及异或（XOR）等逻辑运算。

控制单元（CU）将解释执行指令寄存器（IR）中的指令；也就是说，它使得指令操作码所指定的指令被执行。它利用时钟脉冲流和操作码生成控制计算机总线、存储器、寄存器与功能单元的信号。

**地址**就是存储器中一个字位置的二进制表示。处理器采用寄存器-寄存器型体系结构，在执行一条形如ADD r1,r2,r3的指令时需要3个寄存器地址。当计算机在寄存器与存储器之间传递数据时需要两个操作数：寄存器和存储单元地址。

下述RTL记号表明了处理器如何读出并执行指令LDR　r1,1234的。  
```
FETCH	[MAR] <- [PC]					;把PC的值复制到存储器地址寄存器
			[PC] <- [PC]+4				;PC递增，指向下一条指令
			[MBR] <- [[MAR]]			;读出地址为MAR的指令
			[IR] <- [MBR]					;将指令从MBR复制到IR

LDR		[MAR] <- [IR(地址)]		 ;把IR中的操作数地址复制到MAR
			[MBR] <- [[MAR]]			;将地址为MAR的操作数读到MBR中
			[r1] <- [MBR]					;把操作数移到寄存器r1
```
[MAR] <- [PC]	程序计数器，包含下一条要执行的指令的地址，它被复制到存储器地址寄存器中，用来访问存储器，读出要被执行的指令。
[PC] <- [PC]+4	程序计数器加4，即指向下一条要执行的指令。指令按照顺序执行，除法有流控制指令改变了原来的顺序。增量为4而不是1是因为ARM指令长为4个字节。
[MBR] <- [[MAR]]	MAR(存储地址)所指的存储单元的内容被复制到存储器数据寄存器（MBR）中。因为MAR包含要执行的下一条指令的地址，MBR则存放了当前指令的操作码。符号[[MAR]]表示地址存放在MAR中的存储单元的内容。  
[IR] <- [MBR]	将存储器数据寄存器的内容复制到指令寄存器IR中。现在IR中存放了要执行的指令。控制单元用指令中的位生成实现该指令所需的控制信号。 

##### （1）常量处理

**立即数**是一个在运算中可以直接使用的数，与存储单元的值完全不同，需要用哈希符号（#）前缀来声明。

##### （2）流控制

**流控制**是指任意能够改变程序中指令顺序执行的动作。换句话说，它是指计算机非顺序执行指令的能力。通常，流控制是指转移到程序中特定位置的分支和跳转指令、子程序/过程调用，返回、中断以及操作系统调用。必须强调的是，流控制是反映计算机做出决策并在多个动作序列间选择的能力的关键因素，这一点十分重要。

流控制的典型例子就是条件行为，它允许处理器在两个可能的动作序列中选择一个执行。计算机通过测试一个操作的结果，然后执行程序中两条路径中的一条来实现条件行为；也就是说，测试结果决定了要将两个不同地址中的哪一个加载到程序计数器中。相应地，存储器将会从两个可能候选指令中读出一个，并将其加载到指令寄存器中。

实现条件控制的信息通路将ALU与程序计数器PC连接在一起，并允许ALU决定接下来要执行两个可选指令中的哪一个。决定分支转移（不转移）的条件就是ALU所执行的操作的结果。ALU的信息将被写入条件码寄存器（CCR），他保存了各种用于测试的条件（如，零、负、正）。也就是说，当ALU执行一个操作时，它会更新CCR中的零位、借位位、负位以及溢出位。

寄存器CCR与控制单元相连。控制单元负责指令译码，并生成必要的控制信号以执行指令。当BEQ等条件分支指令执行时，控制单元从CCR中选择所需的条件位并进行测试。如果测试的条件位为false，则CPU按照正常顺序执行下一条指令。如果测试的条件为true，则CPU就会跳到条件指令分支字段所指定的地址处，该地址被称作**分支目标地址**。

BPL Error（正则跳转）是一条典型条件的指令，如果前一个操作的结果为正，它会跳转到标号为“Error”的代码区域。指令寄存器中的**地址字段**与**程序计数器**之间的地址总线允许将一个**非顺序**地址加载到程序计数器PC中。

**状态信息**	下面进一步分析条件分支是如何实现的。计算机执行一个操作时，它将状态或者条件信息保存在CCR中。处理器记录下结果是否为0，结果的二进制形式是否为负，是否产生进位位，或者是否算术溢出。CCR中的位会在每一次操作后被更新，这一说法并不完全准确。实际情况非常复杂，一个处理器与另外一个处理器的情况完全不同。

**分支指令例子**	下面将说明如何使用条件分支指令BEQ address来实现高级语言结构。首先，处理器用IR中BEQ指令的操作码字段选出CCR中的一位进行测试。如果被测试的位为1，则PC会载入一个新地址，否则PC不变。

### 2.ISA的组成

在详细介绍真正的微处理器之前，必须介绍一下ISA的３个组成部分：寄存器集、寻址方式和指令格式。它们共同定义了汇编语言程序员看待处理器的视角。实际上由两个汇编语言程序员：**人和编译器**。

##### （1）寄存器

从概念上来看，寄存器是计算机中最没用的一部分。它甚至是没有必要的，也不参与任何计算。实际上，20世纪70年代的有些微处理器根本没有片上寄存器；它仅仅是用一组存储单元作为寄存器。片内的一个指针寄存器保存了存储器中寄存器的地址。然而，寄存器对于提高计算机性能和实际指令集设计是很有必要的。

实际计算机用寄存器实现片上存储，寄存器的功能与存储单元一样，唯一的区别在于访问的便捷性和响应时间。仅需很少的指令位就可以指定一个片上寄存器。

由于计算机中只带有少量的片内寄存器，因此有必要通过将数据载入寄存器的指令和将寄存器中数据存入存储器的指令在内存和寄存器之间传递数据（前面已经使用过的LDR和STR操作）。所有数据处理操作都只能针对寄存器的内容，这类计算机叫作载入和存储计算机，它表明对存储器进行的操作只能是将数据传送到寄存器中或者从寄存器中取出数据。这些计算机总是被归于RISC一类。

寄存器的大小（它的位宽）通常等于计算机完成的数据处理操作的最大位宽。

有些计算机允许对寄存器的部分内容（子集）进行操作。一些寄存器将其内容作为二进制补码处理，对寄存器部分内容进行操作的结果被符号扩展到整个字。