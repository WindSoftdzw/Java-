# 体系结构与组成


###### 2019/7/12

### 1.存储程序计算机

ARM这一类处理器采用了存储程序体系结构，它将程序和数据放在同一个存储空间内，采用**取指-执行**模式执行，即按照顺序从内存读取指令、译码、执行。这样一台计算机带有寄存器、逻辑运算单元（ALU）、存储器以及用来链接各个功能部件的总线。程序或者被保存在只读存储器中，或者由操作系统从硬盘加载到内存中。

寄存器是卫浴CPU内部的存储单元，类似与内存中的存储单元。寄存器使用名字而不是地址来访问。这样，计算机指令的操作码就可以使用很少的几位来引用寄存器；指令中用来选择寄存器的字段一般为3~5位，具体数值取决于计算机中程序可见寄存器的个数。

CPU中的寄存器有几个功能。一些寄存器是**高速暂存**寄存器，用于保存数据或者数据单元的地址（即指针）。另外一些则是特殊功能寄存器，比如对一个循环的次数进行计数的循环计数器，有的则用来记录处理器的状态。CPU中最重要的寄存器是**程序计数器（PC）**，它记录了要执行的下一条指令的地址；也就是说，程序计数器保持对程序执行的跟踪。有时PC也叫**指令指针**，这更反映出它的功能。

计算机指令有多种格式。为方便起见，假设通用计算机提供了以下3种指令格式：  
**LDR**	**寄存器**目的，存储单元源  
**STR**	寄存器源，**存储单元**目的  
**Opertation**	**寄存器**目的，寄存器源1，寄存器源2

LDR指令把数据从存储器复制到寄存器，而STR指令则执行相反的操作，即把数据从寄存器传输到存储器。

第三种指令类型带有3个操作数，每个操作数都引用了一个寄存器。指令中的操作码部分被表示为operation，它定义了CPU完成的操作（例如ADD、SUB、AND）。操作码后面的3个**操作数字段**指定了参与操作的寄存器。**源**操作数指明了数据的来源，**目的**操作数指明了结果存放在哪里。

中央处理单元（CPU）包括了算逻运算单元（ALU）、寄存器和总线。CPU中还包括控制单元，它是一个硬件子系统，负责取指、译码，并根据译码得到的信息来控制数据在寄存器和功能单元之间的流动，它也是一个输入/输出接口。

寄存器定义如下：  
MAR	存储器地址寄存器，保存了读或者写操作正在访问的存储单元的地址。  
MBR	存储器数据寄存器，保存了刚从存储器中读出的数据，或将写入存储器的数据。  
PC	程序计数器，保存了要执行的下一条指令的地址。因此，PC指向存放了下一条指令的存储单元。  
IR	指令寄存器，存放最近从存储器中读出的指令。也就是当前正在执行的指令。  
r0-r7	寄存器文件，包括8个通用目的寄存器r0,r1,r2,...,r7，用于存放临时（工作）数据（例如计算的中间结果）。一台计算机至少需要一个通用寄存器。我们的简单计算机中有8个通用寄存器。 

除寄存器外，计算机中还带有用来在寄存器之间以及寄存器与算逻运算单元之间传送信息的总线。ALU通过单操作数运算（单值或一元运算）或者双操作数运算（双值或二元运算）对数据进行处理。一元运算的典型例子有取负、递增、清除；二元运算的典型例子有与（AND）以及异或（XOR）等逻辑运算。

控制单元（CU）将解释执行指令寄存器（IR）中的指令；也就是说，它使得指令操作码所指定的指令被执行。它利用时钟脉冲流和操作码生成控制计算机总线、存储器、寄存器与功能单元的信号。

**地址**就是存储器中一个字位置的二进制表示。处理器采用寄存器-寄存器型体系结构，在执行一条形如ADD r1,r2,r3的指令时需要3个寄存器地址。当计算机在寄存器与存储器之间传递数据时需要两个操作数：寄存器和存储单元地址。

下述RTL记号表明了处理器如何读出并执行指令LDR　r1,1234的。  
```
FETCH	[MAR] <- [PC]					;把PC的值复制到存储器地址寄存器
			[PC] <- [PC]+4				;PC递增，指向下一条指令
			[MBR] <- [[MAR]]			;读出地址为MAR的指令
			[IR] <- [MBR]					;将指令从MBR复制到IR

LDR		[MAR] <- [IR(地址)]		 ;把IR中的操作数地址复制到MAR
			[MBR] <- [[MAR]]			;将地址为MAR的操作数读到MBR中
			[r1] <- [MBR]					;把操作数移到寄存器r1
```
[MAR] <- [PC]	程序计数器，包含下一条要执行的指令的地址，它被复制到存储器地址寄存器中，用来访问存储器，读出要被执行的指令。
[PC] <- [PC]+4	程序计数器加4，即指向下一条要执行的指令。指令按照顺序执行，除法有流控制指令改变了原来的顺序。增量为4而不是1是因为ARM指令长为4个字节。
[MBR] <- [[MAR]]	MAR(存储地址)所指的存储单元的内容被复制到存储器数据寄存器（MBR）中。因为MAR包含要执行的下一条指令的地址，MBR则存放了当前指令的操作码。符号[[MAR]]表示地址存放在MAR中的存储单元的内容。  
[IR] <- [MBR]	将存储器数据寄存器的内容复制到指令寄存器IR中。现在IR中存放了要执行的指令。控制单元用指令中的位生成实现该指令所需的控制信号。 

##### （1）常量处理

**立即数**是一个在运算中可以直接使用的数，与存储单元的值完全不同，需要用哈希符号（#）前缀来声明。

##### （2）流控制

**流控制**是指任意能够改变程序中指令顺序执行的动作。换句话说，它是指计算机非顺序执行指令的能力。通常，流控制是指转移到程序中特定位置的分支和跳转指令、子程序/过程调用，返回、中断以及操作系统调用。必须强调的是，流控制是反映计算机做出决策并在多个动作序列间选择的能力的关键因素，这一点十分重要。

流控制的典型例子就是条件行为，它允许处理器在两个可能的动作序列中选择一个执行。计算机通过测试一个操作的结果，然后执行程序中两条路径中的一条来实现条件行为；也就是说，测试结果决定了要将两个不同地址中的哪一个加载到程序计数器中。相应地，存储器将会从两个可能候选指令中读出一个，并将其加载到指令寄存器中。

实现条件控制的信息通路将ALU与程序计数器PC连接在一起，并允许ALU决定接下来要执行两个可选指令中的哪一个。决定分支转移（不转移）的条件就是ALU所执行的操作的结果。ALU的信息将被写入条件码寄存器（CCR），他保存了各种用于测试的条件（如，零、负、正）。也就是说，当ALU执行一个操作时，它会更新CCR中的零位、借位位、负位以及溢出位。

寄存器CCR与控制单元相连。控制单元负责指令译码，并生成必要的控制信号以执行指令。当BEQ等条件分支指令执行时，控制单元从CCR中选择所需的条件位并进行测试。如果测试的条件位为false，则CPU按照正常顺序执行下一条指令。如果测试的条件为true，则CPU就会跳到条件指令分支字段所指定的地址处，该地址被称作**分支目标地址**。

BPL Error（正则跳转）是一条典型条件的指令，如果前一个操作的结果为正，它会跳转到标号为“Error”的代码区域。指令寄存器中的**地址字段**与**程序计数器**之间的地址总线允许将一个**非顺序**地址加载到程序计数器PC中。

**状态信息**	下面进一步分析条件分支是如何实现的。计算机执行一个操作时，它将状态或者条件信息保存在CCR中。处理器记录下结果是否为0，结果的二进制形式是否为负，是否产生进位位，或者是否算术溢出。CCR中的位会在每一次操作后被更新，这一说法并不完全准确。实际情况非常复杂，一个处理器与另外一个处理器的情况完全不同。

**分支指令例子**	下面将说明如何使用条件分支指令BEQ address来实现高级语言结构。首先，处理器用IR中BEQ指令的操作码字段选出CCR中的一位进行测试。如果被测试的位为1，则PC会载入一个新地址，否则PC不变。

### 2.ISA的组成

在详细介绍真正的微处理器之前，必须介绍一下ISA的３个组成部分：寄存器集、寻址方式和指令格式。它们共同定义了汇编语言程序员看待处理器的视角。实际上由两个汇编语言程序员：**人和编译器**。

##### （1）寄存器

从概念上来看，寄存器是计算机中最没用的一部分。它甚至是没有必要的，也不参与任何计算。实际上，20世纪70年代的有些微处理器根本没有片上寄存器；它仅仅是用一组存储单元作为寄存器。片内的一个指针寄存器保存了存储器中寄存器的地址。然而，寄存器对于提高计算机性能和实际指令集设计是很有必要的。

实际计算机用寄存器实现片上存储，寄存器的功能与存储单元一样，唯一的区别在于访问的便捷性和响应时间。仅需很少的指令位就可以指定一个片上寄存器。

由于计算机中只带有少量的片内寄存器，因此有必要通过将数据载入寄存器的指令和将寄存器中数据存入存储器的指令在内存和寄存器之间传递数据（前面已经使用过的LDR和STR操作）。所有数据处理操作都只能针对寄存器的内容，这类计算机叫作载入和存储计算机，它表明对存储器进行的操作只能是将数据传送到寄存器中或者从寄存器中取出数据。这些计算机总是被归于RISC一类。

寄存器的大小（它的位宽）通常等于计算机完成的数据处理操作的最大位宽。

有些计算机允许对寄存器的部分内容（子集）进行操作。一些寄存器将其内容作为二进制补码处理，对寄存器部分内容进行操作的结果被符号扩展到整个字。

###### 通用寄存器vs特殊功能寄存器

8086所用的IA32体系结构使用了一组特定的16位寄存器叫做AX、BX、CX和DX，每个寄存器可被分解为一对寄存器，用作字节寄存器。它还有4个变址（指针）寄存器和4个段寄存器。需要强调的是，8086的寄存器都是高度专用的，程序员必须记住每个寄存器都能做什么以及哪条指令使用哪个寄存器。

提供特殊功能寄存器意味着无需在指令字·中分配一些位去指明它的用途。使用专用寄存器会使代码更加紧凑，这在微处理器发展的早期是一个非常重要的特性，因为早期存储器的价格是现在的数百万倍。

Motorola，在8086之后不久研发了68K处理器。这是一个使用32位寄存器的32位处理器。它使用通用寄存器，包括8个数据寄存器D0~D7和8个地址（指针）寄存器A0~A7。所用寄存器都可以互换使用，当然，采用这种方法意味着所有基于寄存器的指令都需要3位寄存器选择字段以区分寄存器。

ARM由16个通用寄存器r0~r15。寄存器r0~r13可互换使用，行为相似。寄存器r14和r15还有额外的功能（r14为链接寄存器，保存子程序返回地址；r15为程序计数器）。尽管人们希望能自由地使用寄存器r13，但良好的编程实践却要求保存r13以使用栈指针。

##### （2）寻址方式概述

* 立即数寻址
* 直接寻址
* 间接寻址

前面已经见到过这些寻址方式。最简单的寻址形式是立即数寻址，其操作数是指令的一部分。由于它是指令的一部分，它没有被保存在存储单元或寄存器中，而成为指令的组成部分。立即数寻址意味着操作数为常数，它的值不能在程序执行过程中改变。

这种寻址方式也叫**立即寻址**，因为操作数立即可用。计算机也会使用立即数寻址来设置在程序执行过程中不会改变的常量。

第二种方法是**直接寻址**，也称绝对寻址。这种寻址方式是把操作数地址用作指令的一部分。Load-store型计算机，比如ARM，没有实现直接寻址。所有存储器操作数要么被指定为立即数，要么通过寄存器指针间间接指定。

第三种寻址方式有许多名称——本书中叫作**间接寻址**，或者更严格地说，叫作**寄存器间接寻址**。在寄存器间接寻址中，指令给出了包含操作数地址的寄存器的地址。获得一个操作数需要3次访问：读指令，读含有操作数地址的寄存器，以及最后读出实际的操作数。含有操作数地址的寄存器称作指针寄存器。Load-store型计算机使用这种寻址方式访问存储器操作数。

寄存器间接寻址对访问表格和数组非常有用，因为它可以操作指针寄存器访问数组元素。寄存器间接寻址有许多变种。最常用的格式是带偏移量的寄存器间接寻址，其中操作数的地址由寄存器内容加上常量或者偏移量指定。

这一寻址方式带有一个立即数常量，它在编写程序的时候就已经确定。带偏移量的寄存器间接寻址允许使用指针指向数据区的基地址，而用偏移量指明数组中给定的元素。

###### 存储器与寄存器寻址

前面已经指出，寄存器与存储单元之间没有本质区别。其区别主要体现在它们的相对访问速度以及指定一个寄存器和一个存储单元所需的地址位数上。在实践中，这意味着8位计算机时代计算机指令不能实现较长的存储器地址。若没有意外，一条指令只能提供一个存储器地址。

由此可以推出，这些计算机不支持存储器—存储器操作。因此，微处理器一般提供3种指令模式：

* **存储器—寄存器型**：源操作数在存储器中，目的操作数在寄存器中；
* **寄存器—存储器型**：源操作数在寄存器中，目的操作数在存储器中；
* **寄存器—寄存器型**：两个操作数都在寄存器中。

Freescale 68K确实支持存储器—存储器型操作（仅支持MOVE指令），这时源操作数和目的操作数都在内存中。这条指令长10个字节（80位），因为它需要16位指令字后跟两个32位的地址。

##### （3）指令格式

体系结构就是计算机指令本身，这是指令集的重点所在。指令指明了下一步要执行的操作。仅考虑指令长为一个字的情形，它指定了要执行的操作以及其他额外信息（即立即数、寄存器或地址）。

RISC计算机，比如ARM和MIPS，其指令受到了严格限制；指令长度必须规整为一个字。因此，指令集设计者受到指令字长的约束。CISC计算机通过允许指令长度扩展为几个字解决了固定指令长度的问题。

计算机设计的历史中充斥着各种试图打破这一约束的尝试，即 *操作码位数* + *操作数位数*  = *计算机字长*。前面曾说到过立即数的范围为0~900。使用一个10位的字段可以编码范围为0~1023内的立即数。因此，从901~1023之间的123个立即值可以分配给新的指令。当然，这些新指令只能完成那些不需要立即数的操作。如果说“天下没有免费的午餐”，那么在指令集设计的领域也是如此。

##### （4）操作码与指令

可以用几种方法将指令分组或分类。计算机体系结构设计中最重要的一个因素是每条指令中操作数地址的数量。例如，实现了指令ADD r1，r2，r3的指令集是*三地址*计算机，而实现了ADD，r1，r2指令的计算机是*双地址*的。也可以按照操作的性质来将指令分组。例如，*数据移动*指令把数据从一个地方移到另一个地方；*数据处理*指令进行数据运算，而*流控制*指令修改指令执行的顺序。

###### 双地址计算机

CISC计算机采用*双地址*指令格式。明确的说，不能仅用两个操作数就完成指令P = Q＋R。但可以执行操作Q<- P + Q。有个操作数出现了两次：第一次为源操作数，第二次作为目的操作数。操作ADD P，Q执行运算[Q] <- [P] + [Q]。双操作数指令格式的代价是一个源操作数的内容会因为覆写而遭到破坏。绝大多数计算机指令不能直接访问两个存储单元。典型情况下，操作数要么是两个寄存器，要么是一个寄存器和一个存储单元。

###### 单地址计算机

单地址计算机在指令中仅指定了一个操作数。第二个操作数是一个叫*累加器*的固定寄存器，它无需指定。

八位计算机采用单地址结构。可以想象，8位代码是很冗长的，因为必须将数据加载到累加器进行处理，然后把结果存放起来以避免被下一条数据处理指令覆盖。目前单地址计算机仍被广泛地应用于超低功耗、低性能的系统中。

###### 零地址计算机

零地址计算机使用根本没有地址的指令。零地址计算机对位于栈顶的数据进行处理，因此通常也被称作*栈计算机*。当然，一个纯粹的零地址计算机是不实用的。需要通过load和store指令从存储器中读出数据或把数据保存到存储器中。

单操作数运算（一元运算，如取负、清零、递增、递减）作用于栈顶数据，而双操作数运算（二元运算，如加、乘、逻辑或）首先从栈顶取出两个元素，进行运算，然后将结果入栈。将一个数据放到栈顶的操作叫作入栈（PUSH），而从栈顶取出一个数据的操作叫作出栈（POP）。

除了常规数据处理运算外，零地址计算机也包括使堆栈编程更加方便地数据控制运算。例如，支持栈顶数据复制或者栈顶两个数据项交换的指令。

高级语言Java被编译成一种低级的基于栈的语言，叫作**字节码**，并在真实计算机上解释执行。有些ARM处理器集成了Jazelle直接字节码执行，能够直接执行字节码。由硬件直接执行字节码提高了ARM运行Java应用时的性能。

###### 一个半地址计算机

Intel IA32系列与Freescale系列通常叫作**一个半地址**计算机，这是因为它们的指令指定了两个操作数，一个操作数是存储器地址，另外一个操作数则是寄存器地址。寄存器地址被讽刺地称为半个地址，因为与GB量级的存储空间相比，寄存器的数量很少。

### 3.ARM指令集体系结构

##### （1）ARM寄存器集

ARM共有14个通用寄存器r0~r13。寄存器r14存放子程序返回地址，r15为程序计数器。由于r15能够被程序员所访问，因此能够执行可以计算的分支。ARM仅有16个通用寄存器，作为一个RISC处理器还是很少见的。16个寄存器需要4位地址，相对于带有32个寄存器的RISC处理器来说每条指令可节约3位。这种方法使得ARM的指令比一些RISC处理器丰富得多。寄存器r13被保留用作栈指针。与特殊功能寄存器r14和r15不同，它们的附加功能由ARM的硬件实现，仅当程序员需要使用r13作为栈指针时它才会成为栈指针。

ARM的**当前处理器状态寄存器（CPSR）**包括Z（零）、N（负）、C（进位）和V（溢出）等标志位，类似于其他处理器中的条件码或状态寄存器。



##### （2）ARM指令集

| 指令 |  ARM助记符   |             RTL定义 |
| :---: | :----------: | :------------------: |
| 加法 | ADD r0,r1,r2 | [r0] <- [r1] + [r2] |
| 减法 |SUB r0,r1,r2 | [r0] <- [r1] - [r2]|
|与| AND r0,r1,r2|[r0] <- [r1] · [r2] |
|或|ORR r0,r1,r2|[r0] <- [r1] + [r2]|
|异或|EOR r0,r1,r2|[r0] <- [r1] &oplus; [r2] |
|乘|MUL r0,r1,r2|[r0] <- [r1] x [r2]|
|寄存器—寄存器移动|MOV r0,r1|[r0]<-[r1]|
|比较|CMP r1,r2|[r1]-[r2]|
|相等跳转|BEQ label|[PC] <- label(跳转到label处)|

### 4.ARM汇编语言

汇编程序由两部分语句组成：计算机**可执行指令**和告诉汇编器运行环境有关信息的**汇编伪指令**。汇编伪指令告诉汇编器代码在存储器中的位置，为变量分配存储空间，以及设置程序运行时所需的初始数据。

##### （1）汇编器的实际考虑因素

EQU和DCD是两个重要的汇编伪指令，EQU把一个名字与一个值绑在一起，DCD在程序运行前将数据提前载入存储空间。伪指令EQU很容易理解。它把一个数字值绑定（即附加）到一个名字上。

汇编语言程序可以使用常量、变量和数据结构。它们都被存储在存储器中的某些位置。计算机用户从来不必关注这些，因为操作系统和系统软件会自动为数据分配存储空间。高级语言程序员一般通过变量或常量声明来分配存储空间。

助记符DCD在存储器中预留一个32位字的存储空间，并且把它右边表达式的值加载到该存储单元中。

位置计数器按4字节递增，这样下一个DCD或指令将会保存到下一个字存储单元中。术语“位置计数器”是指在程序进行汇编时指向下一个存储单元的指针，它在概念上类似于程序计数器。

**魔术代码：** 它是运行环境或操作系统的功能。

##### （2）伪指令

下面介绍伪指令，它是程序员可用的指令，但不是处理器ISA的一部分。伪指令是一种速记形式，程序员可以用它简单地表示一个动作，并使汇编器生成合适的代码。

**ADR**是ARM最有用的指令之一，它把地址加载到目的寄存器中。该指令的格式为 ADR $r_{destination}$,label，这里label是程序中有效地址的标号。尽管我们会在程序中看到ADR，但它并不是一个真正的指令，因为没有指令能把32位常量加载到ARM寄存器中。ADR是一个可由程序员使用的伪操作或虚拟指令，之后汇编器将生成能完成同样功能的实际机器代码。伪指令是一种便捷的形式，汇编器将其转换为实际指令，将除程序员从一些事务性工作解脱出来。一般来说，ADR能够利用ARM的ADD或SUB指令以及PC**相对寻址方式**产生所需要的地址。

另一个很有用的伪指令是 LDR rd， = value。在这个例子中，编译器会生成将已知值载入寄存器rd中的代码。

### 5.ARM数据处理指令

##### （1）算术指令

###### 加法与减法

除了将两个字相加的“一般化操作”以外，绝大多数微处理器都实现了带进位的加法指令，能够将两个操作数和条件码寄存器中的进位位加到一起。这条指令会使字长大于计算机固有字长的链接运算更加方便。

