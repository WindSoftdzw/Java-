# 计算机算术

###### 2019/7/7

###### 16：50

### 1.数据是什么

数据是各种各样的信息，如数字、文本、计算机程序、音乐、图像、符号、运动图像、DNA密码，等。实际上信息是能够被计算机存储和处理的任何事物。

##### （1）位与字节

计算机内存储和处理信息的最小单位是位（bit，或比特)。一个比特的值可以是0或1，它是不可分的，因为不能再将它分为更小的信息单位。数字计算机将信息以一组或一串比特的形式保存在存储器中。  
计算机通常不会每次只对一个二进制位进行操作，它们会对一组二进制位进行操作。8个二进制位为一个字节（byte）。现在的微处理器都是面向字节的，其字长是8位的整数被。一般来讲，计算机能够同时处理的位数越多，它的速度就会越快。

##### （2）位模式

###### 信息表示

一个n位的字可以表示$2^n$个不同的模式，那么一个n位的二进制字又可以表示什么呢？最简单的答案是什么也表示不了，因为一个由二进制1和0组成的串没有任何内在意义。

**指令**	字长位32位或更长的计算机用一个字来表示CPU能够完成的操作（8位或16位计算机用多个字表示一条指令）。指令的二进制编码与其功能之间的关系由计算机设计者决定。例如，一台计算机上表示“A加B”的二进制序列可能与另外一台计算机上的完全不同。

**数量**	一个字或多个字都可以用来表示数量。数可被表示位多种格式（如BCD整数、无符号二进制整数、有符号二进制整数、二进制浮点数、整数复数、浮点复数、双精度整数，等等）

**字符**	字符是一个叫做“字母表”的集合中的元素。拉丁或罗马字母表中的字母、数字符（A-Z，a-z，0-9）和*、-、+、！、？等符号都被分配了二进制值，因此可以在计算机内存储和处理。ISO 7位字符码或ASCII码是在计算机工业中应用得非常广泛得一种编码，它用7位表示一个字符，一共可以表示$2^7 = 128$个不同的字符。其中有96个字符是可打印字符。其余32个是不可打印的，用于完成回车、退格、换行等特殊功能。

**图像、声音和视觉**	数字计算机处理大量表示声音、静态图像和视频的数据。  
组成照片的基本单位是像素，每个像素的大小可以是8位（单色）或24位（三基）。一张高分辨率照片中可能有超过4Kx3K个像素。运动图像的情况更甚，因为视频将作为一串静态图像依次传输，每秒发送60次。实际情况并不像数据所反映的那样糟糕，因为无论是静态图像还是动态图像，都可以进行压缩以减少其数据量——压缩比可以达到10多倍甚至更高。静态图像用JJPEG算法压缩，动态图像则用MPEG算法压缩。  
声音的存储和处理曾是计算机设计者面临的巨大挑战，但与图像相比这已不再是一个严峻的问题，因为音频处理所需的计算、存储和传输宽带已经完全处于现代计算、存储和传输设备的能力范围内。奈奎斯特抽样定律指出，如果以至少两倍于音频流最高频率的速率对初始波形进行采样，就可以重构造出声音信号。使用高级心理声学模型编码方法和MP3等算法对声音进行压缩，可以将其所需带宽降到最初的10分之一。

### 2.数字

用来计数的数字被称作自然数。但并非所有的数字都是自然数。人们发明了负数来处理如银行存款余额等情况。还创造出实数描述123.456和13/14那样的数。实数可分为有理数和无理数。有理数可被表示为分数，而无理数不能被表示为一个整数除以另一个的形式。  
现代数字系统中，有一个符号表示0，该系统使用位置计数法表示十进制数，每个数位的值或权取决于它在数字中的位置。在位置计数法中，当一个属只剩一位时所乘的数的值称作**基数**。

##### （1）位置计数法

按照位置计数法，一个n位的整数N将按照下面的形式书写：  
								$a_{n-1},a_{n-2},\cdots ,a_i,\cdots,a_1,a_0$  
这里$a_i(i=0,1,\cdots,n-1)$是与b的幂相乘的系数（此处b为基数）。  
用小数点将整数部分和小数部分分开，可以对位置计数法进行扩展，使其能够表示实数。十进制运算中的实数按照形如1234.567的方式书写。一个小数点前有n位，小数点后有m位的实数被表示为$a_{n-1}a_{n-2}\cdots a_i\cdots a_1a_0.a_{-1}a_{-2}\cdots a_{-m}$。 
一个用基数b的位置计数法表示的数的值被定义为：  
$N = a_{n-1}b^{n-1}+ \cdots +a_1 b^1+a_0 b^0+a_{-1}b^{-1}+\cdots+a_{-m}b^{-m} = \sum_{i=-m}^{i=n-1} a_i b^i$  
采用位置计数法，一个数的数值等于它各位值得总和，而每一位得值则是该位的数值乘以它在数种的位置所对应的权。

### 3.二进制运算

二进制算术运算的规则与十进制基本相同；唯一的区别在于，十进制算术运算以10为基数，每位有10个数字，而二进制运算以2为基数，每位只有2个数字。

**二进制加法** 两个位相加可能产生进位或错位，就像十进制算术运算中那样。  
真实计算机处理8位、16位、32位或64位的数字，一个字中的所有位都必须参与算术运算。当两个二进制字相加时，一个加数中所有的位都将与另一个加数中对应的位相加，从最低为开始，每次处理一位。加法产生的进位应参与其左边一列中两位的加法。

**二进制减法** 当两个二进制数相减时，0-1的差为1，同时会从其左侧借一位。

**二进制乘法** 两个n位字相乘将产生了1个2n位的积。乘法运算从被乘数的最低位开始，测试它的值是0还是1。如果该位为0，则在算式中写下n个0；如果该位为1，则写下这个乘数（这个值被称作部分积）。接下来继续测试被乘数左边的下一位并执行同样的操作。这个过程将一直继续，直到被乘数中的每一位都按顺序被检测过。最后，这n个部分积被加到一起，生成乘数与被乘数的积。

### 4.有符号整数
##### （1）符号及值表示法

一个n位字可以表示从$0$~$2^{n-1}$共$2^n$个可能的值。表示负数的一种方法是用它的最高位表示符号。通常符号位为0表示正数，符号位为1表示负数。  
有符号数的值可被表示为$(-1)^S*M$,这里S为数的符号位的值，M为其数值部分。  
n位有符号的表示范围为$-(2^{n-1}-1)$至$+(2^{n-1}-1)$。  
符号及值表示法并没有被用于整数算术运算中，因为它的加、减法运算分别用加法器和减法器实现。

##### （2）二进制补码运算

微处理器用二进制补码系统表示由符号整数，因为它可以将减法运算转换为对减数的补数的加法运算。用7+5的补数就可以完成运算7-5。  
在n位二进制算术中，数P的补数为Q且$P+Q=2^n$。在二进制算术中，求一个数的补数的方法是将其各位取反并加一。一个n位二进制数N的二进制补码定义为$2^n-N$。

二进制补码算术可不是魔术。请考虑n位二进制算术运算Z=X+Y，我们用X加上Y的补数来完成这一运算。Y的补码为$2^n-Y$，则有$Z=X+(2^n-Y)=2^n+(X+Y)$。

**补码的特点**	1）补码是一个真正的互补系统，因为+X+（-X）=0。

​						2）补码0被表示为00$\cdots$0，是唯一的。

​						3）补码的最高位为符号位。如果符号位为0，则该数为正；符号位为1，则该数为负。

​						4）n位二进制补码数的表示范围为$-2^{n-1}$~$2^{n-1}-1$。对于n = 8，补码表示范围为-128 ~ 127。共							  有$2^8 = 256$个不同的数。

​						5）补码加法和减法使用同样的硬件完成，因为补码减法由被减数加上减数的补数实现。

**运算溢出**	n位二进制补码数的表示范围为$-2^{n-1}$~$2^{n-1}-1$。如果破坏了这个规则，即运算结果位于这个范围之				   外，会发生**运算溢出**，它发生在补码加法当两个正数的和为负数，或两个负数的和为正数的时候。如果				   操作数A和B的符号位相同但结果的符号位与它们不同，则发生了溢出。假设A的符号位为$a_{n-1}$，B的符				   号位为$b_{n-1}$，A与B之和的符号位为$S_{n-1}$，则可以用下面的逻辑表达式判断是否溢出  
					$V = a_{n-1}\cdot b_{n-1} \cdot  \overline{s_{n-1}}+ \overline{a_{n-1}} \cdot  \overline{b_{n-1}} \cdot s_{n-1}$  
					实践中，真实系统通过加法器的进位输入和输出的最高位来判断是否发生溢出，即$V=C_{in} $ ≠ $C_{out}$。					溢出是补码运算的结果，不应与进位混淆，是否产生进位由被加数与加数的最高两位之和决定。

### 5.乘除法简介

##### （1）移位运算

算术移位运算，简称为“移位”。进行移位运算时，一个数的所有位都会向左或向右移动一位。有些计算机每次可以移动多位。  

二进制补码正数左移一位等价于将该数乘2。二进制右移一位相当于它除以2。

##### （2）无符号二进制乘法

计算机从乘数的最低位开始，每次检查一位，判断它是否为0.如果乘数的当前位为1则写下被乘数，若该位为0则写下n个0。接下来检查乘数的下一位，但这时应从上一个数的左边一位开始写下被乘数。被写下的这一组叫作部分积。在得到所有的部分积之后，将它们加到一起，得到乘法的结果。

##### （3）快速乘法

有些程序员使用移位和加法等速度相对较快的操作以避免使用乘法。  
乘法运算也可以借助查找表实现，这种方法将两个数相乘所有可能的积都保存在一个只读存储器内。这样，只需简单地用X和Y的值找到表中的对应项就可以得到X和Y的乘积。例如，两个8位二进制数乘法需要一个16位地址、$2^{16}$项的查找表，每项记录一个16位的积。

这种方法的缺点在于所需的ROM的容量随着乘数和被乘数位数的增加呈指数增长。n位乘法需要的ROM容量位$2n \times 2^{2n}$位。

可以用一个简单的方法来减少查找表的大小。假设要计算两个16位数A与B的乘积。可以将16位数A拆分为两个8位数$A_u$和$A_i$，这里$A_u$是A的低8位，$A_i$是A的低8位。如果A= 1111000010101010，则$A_u = 11110000$,$A_i = 10101010$。A可被表示为$A_u \times 256 + A_i$,B可以被表示为$B_u \times 256 + B_i$。

$A \times B = (A_u \times 256 + A_i) \times (B_u \times 256+B_i) = 65536A_uB_u+256A_iB_u+256A_uB_i+A_iB_i$

这个表达式需要计算4个8位乘积$(A_uB_u,A_iB_u,A_uB_i,A_iB_i)$，将积左移16位或8位，以及将4个部分积相加等操作。

##### （4）除法

除法是通过被除数不断减去除数直到结果为零或小于除数来实现的。减去除数的次数称作“商”，最后一次减法的差称作“余数”。

**恢复余数除法**	稍加改动，刚才讨论的除法方法就可以以数字形式实现。唯一需要修改的就是除数与部分被除数的比较方法。计算机必须做减法并检测结果的符号位。如果减法的结果为正，则商1，但结果为负，则应商0并将部分被除数与除数相加，将其恢复为原先的值。

下面是一个可行的恢复余数除法算法。

1) 将除数的最高位与被除数的最高位对齐。
2) 从部分被除数中减去除数，得到新的部分被除数。
3) 若新的部分被除数为负，则商0并用新的部分被除数加上除数，恢复原先的部分被除数。
4) 若新的部分被除数为正，则商1。
5) 判断除法是否结束。若除数的最低位与部分被除数的最低位对齐，则除法结束。最后的部分被除数就是余数。否则，执行6）。
6) 将除数右移一位。从第二步开始执行。

**不恢复余数除法**	改进恢复余数除法可以减少除法的延迟。不恢复余数除法与恢复余数除法基本相同，唯一的区别在于它取消了恢复余数的操作。在恢复余数除法中，在部分被除数与除数相加恢复被除数之后的一个周期，部分被除数将减去除数的二分之一。每个将除数右移的操作等价于将除数除以2。当前周期恢复部分被除数以及下个周期减去除数一半的操作等价于部分被除数加上除数的一半。即D-D/2 = +D/2，这里D为除数。

### 6.浮点数

**浮点运算**，即实数之间的运算。实数是所有有理数和无理数的集合。浮点运算能够让人们处理科学应用中很大的和很小的数。浮点运算不像整数运算，它的计算结果一般是不确定的。一块芯片上的浮点计算结果也许与另一块芯片上的不同。

n位字长的计算机能够处理值为0~$2^{n}-1$的单字长无符号整数。更大的整数可以通过将多个字链接在一起来表示。科学家和工程师经常会处理值范围极大的数。这些数被表示为浮点数并进行处理，之所以这样叫是因为小数点在数中的位置并不是固定的。一个浮点数值分两部分储存：数值以及小数点在数值中的位置。

二进制浮点数则被表示为$尾数 \times 2^{指数}$的形式。由于浮点数被定义为u两个值的积，浮点数的表示并不唯一。

20世纪70年代，一种标准的浮点数表示方式快速地取代了大多数系统自有的格式，IEEE 754浮点数标准提供了3种浮点数表示方式：32位单精度浮点数，64位双精度浮点数，以及128位四精度浮点数。

**规格化浮点数**	IEEE 745浮点数的尾数总是规格化的，其范围为$1.000\cdots 0 \times 2^e$到$1.111\cdots 1 \times 2^e$，这里e为指数。规格化浮点数的最高位总是1.规格化使尾数的所有位都是有效的，因而尾数的精度最高。尾数规格化充分利用了可用的最大精度。

**偏置指数**	IEEE 754浮点数的尾数被表示为符号和数值的形式，即用一个符号位表示它是正数还是负数。它的指数则用偏置方式表示，即给指数加上一个常数。这种用偏置表示指数的方法的优点在于，最小的负指数被表示为0。若不采用这种方法，0的浮点表示为$0.0 \cdots 0\times 2^{最小负指数}$。采用偏置之后，0的浮点就可以用尾数0和指数0表示。

### 7.浮点运算

浮点数不能直接相加。为了对齐指数，计算机必须执行下面的步骤：

1. 找出指数较小的那个数

2. 使两个数的指数相同。对于指数小的那个数，指数加几，就将尾数右移几位。

3. 尾数相加（或相减）

4. 如果有必要，将结果规格化（后规格化）  

加法需要对结果进行规格化处理。在运算过程中，有以下几点需要注意：

1. 因为指数有时与尾数位于同一个字中，在加法过程开始之前必须将它们分离开（解压缩）
2. 如果两个指数的差大于p+1，这里p为尾数的位数，较小的那个数由于太小而无法影响较大的数，结果实际上就等于较大的那个数
3. 结果规格化时会检查指数，看它是否比最小 指数小或比最大指数大，以分别检测指数下溢或上溢。指数下溢会导致结果为0，而指数上溢会造成错误，可能会要求操作系统介入处理。 

**舍入和截断误差**	因为浮点运算可能会引起尾数的增加，因此需要能够保持尾数位数不变的方法。最简单的技术叫作截断。截断会产生诱导误差（即误差是由施加在数上的操作计算引起的），诱导误差时偏置的，因为截断后的数总是比截断前小。

舍入是一种更好的减少数的位数的技术。如果丢弃的位的值大于剩余数最低位的一半，则将剩余数的最低位加1。与截断相比，人们更青睐舍入，因为它更加精确并会引起非偏置的误差。截断总会使结果变小，带来系统性误差，而舍入有时会使结果减小，有时会使结果增大。舍入的主要不足在于它需要对结果进行一个额外的算术操作。

最简单的舍入机制是截断或向0舍入。“向最近的数舍入”方法，会选择距离该数最近的那个浮点数作为结果。“向正或负无穷大舍入”方法，会选择正或负无穷大方向上最近的有效浮点数作为结果。当要舍入的数位于两个连续浮点数的正中时，IEEE舍入机制会选择最低位为0的点（即向偶数舍入）。

具体实现时，浮点数使用3个专用位辅助完成舍入过程。一个m位的尾数可表示为$1.m_{1}m_{2} \cdots m_m GRS$，这里G为保护位，用于暂时提高浮点数的精度；R为舍入位，用于辅助完成舍入；S为粘位。粘位是R位右侧的所有位进行逻辑与运算后的结果，之所以这样称呼是因为一旦该位被置位它就将保持为1。舍入算法根据以上3位确定舍入位的值。