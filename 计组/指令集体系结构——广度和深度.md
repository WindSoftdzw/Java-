# 指令集体系结构——广度和深度

### 1.数据存储和栈

高级语言程序员用变量代表变量或**抽象数据单元**的数据元素。这些数据单元是抽象的，因为它可能保存程序员定义的任意类型的数据元素。对程序员来说，抽象数据单元具有一个真实存储单元的全部属性：可以从中读也可以向其中写。程序员可以给一个变量命名。将变量名与其存储位置关联在一起的过程被称作**绑定**（绑定的含义比简单地将一个名字与变量连接在一起要多得多）。除了名字以外，变量还有一个与它相关的**作用域**。变量的作用域定义了它在程序内可见或可访问的范围。

每个变量都有**生命期**。为变量分配名字并为它们保留存储空间的即为可声明变量。从汇编语言程序员的视角来看，变量的存在始于它们被载入存储器，止于程序运行结束。然而，在许多高级语言中，变量在一段特定的时间内被绑定到一块存储区上。一旦超出了变量的生命期，这块存储区就会被释放并且可能会与另一个变量绑定在一起。

##### （1）存储和栈

当某种汇编语言使用动态数据存储调用一个过程时，这被称作**激活**了一个过程。每个过程以及每次过程调用都有一个与其关联的**激活记录**，它包含所有执行该过程所必须的信息。读者可以将一个激活记录视作过程对世界的视图。支持递归的编程语言使用动态存储，因为所需的存储空间随程序的执行变化。存储必须在**运行时**分配。

激活记录有时也被称作**帧**。当一个激活记录被使用过之后，执行从过程返回的命令会**释放**该记录所占的存储空间。

###### 栈帧与局部变量

过程通常需要为它们的临时变量申请**局部工作区**。术语”局部“的意思是工作区是过程私有的，不能被调用程序或其他子程序访问。如果一个过程是**可重入**的或递归使用的，它的局部变量不仅与过程本身也与它的使用情况密切相关。换句话说，每次调用一个过程都必须为它分配一个新的工作区。如果一个过程已被分配了区域固定的工作区，它的运行被中断又被中断例程调用，那么固定区域内的任何数据都有可能被过程的重用所覆盖。

栈为工作区的动态分配提供了实现机制。**栈帧**和**帧指针**是与动态存储技术有关的两个概念。栈帧是位于当前栈顶部的一块临时存储区域。

在从子程序返回之前，必须执行指令释放栈帧。通常，对栈帧的操作必须是**平衡**的；即如果将一些数据放在栈帧中，那么一定要记得将其移除。

可以用栈指针来访问栈帧中的临时变量。因为栈指针会随着其他信息进入或离开栈而移动，最好构造一个带有独立于栈指针的固定指针的栈帧。

ARM处理器既没有创建栈帧的指令，也没有返回时释放栈帧的取消链接指令。必须通过一些比较麻烦的方法完成这些操作。

##### （2）通过栈传递参数

可以通过两种方式将参数传递给过程：通过**值**和通过**引用**。在前一种方法中，传递的是参数实际值的拷贝；而在后一种方法中，参数的地址在程序和过程/函数间传递。这一区别非常重要，因为它会影响参数处理的方法。当通过值来传递参数时，过程将收到参数的一份拷贝。如果该过程修改了这个参数，新的参数值不会影响保存在程序中某处的该参数的旧值。换句话说，通过值来传递参数会克隆参数值并且过程会使用克隆的值。过程不会返回克隆的值。

当通过引用传递参数时，过程将收到一个指向参数的指针。这时，参数只有一份拷贝，过程能够访问到参数的值，因为它知道参数的地址。如果过程修改了参数，它将进行全局修改而不是仅在过程内修改。

### 2.特权模式和异常

中断和异常是一些强制计算机停止**正常**处理并调用**异常处理程序**（通常是操作系统的一部分）进行异常处理的事件。异常是为响应内部硬件、或软件错误、或外设请求而引起的。程序员可以使用软中断指令调用操作系统函数，比如输入或输出操作。

在任一时刻，ARM处理器都在下表列出的某一种模式下工作。CPSR的第5位定义了当前模式。最普通的操作模式是**用户模式**。只要发生了中断或异常就会发生一切模式切换。每一种模式都有它自己的保存程序状态寄存器，用于在发生异常时保存当前的CPSR。当异常在新的寄存器r13和r14中切换时，**新的寄存器组**（或体）由表中给出的名称标识。

| 操作模式 | CPSR[4:0] |     使用     | 寄存器体 |
| :------: | :-------: | :----------: | :------: |
|   用户   |   10000   | 普通用户模式 |   user   |
|	FIQ  	|10001|快速中断处理	|_fiq|
|IRQ|10010|中断处理|_irq|
|SVC|10011|软件中断处理|_svc|
|退出|10111|处理存储器故障|_abt|
|未定义|11011|未定义指令处理|_und|
|系统|11111|操作系统|user|

异常可由内部和外部事件引起。外部事件是中断请求（IRQ），包括快速中断请求（FIQ）、复位以及页故障。内部异常则包括软件中断以及未定义的指令。

当发生异常时，ARM处理器会完成当前的指令（除非异常是由该指令的执行所造成的）。然后进入异常处理模式。下面是要发生的事件序列。

1）操作模式改变为异常对应的模式。例如，中断请求会选择IRQ模式。

2）将紧接在异常发生处之后的那条指令的地址拷贝到寄存器r14中。即异常被视作一种子程序调用，返回地址保存在链接寄存器中。

3）将当前处理器状态寄存器（CPSR）的当前值保存在新模式的SPSR中。例如，如果异常是一个中断请求，CPSR将保存在SPSR_irq中。保存当前处理器的状态是必需的，因为异常不得改变处理器状态。

4）将CPSR的第7位置为1，禁止中断请求。如果当前异常是一个快速中断请求，则通过将CPSR的第6位置为1来紧张其他FIQ异常。

5）异常表中的每一项都包含异常处理例程中要执行的第一条指令。该指令通常是一个分支操作。它会将对应的异常处理程序的入口地址加载到程序计数器中。

在恰当的例程处理完异常之后，必须返回到异常发生时的位置（当然，如果是终止异常，就不可能再返回了）。

为了从异常返回，必须将定义了异常前模式的信息保存起来（即程序计数器和CPSR）。不幸的是，从异常返回并不像看起来那样简单。如果先恢复PC，那么仍然处于异常处理模式下。相反，如果先恢复处理器状态，那就不再处于异常处理例程中，也就没有办法恢复CPSR了。

不能使用**普通**的操作系列从异常中返回，因为它涉及操作模式的改变。ARM提供了两种异常返回机制：一种适用于返回地址已经被保存在分体的r14寄存器的情形，另一种则适用于返回地址已经入栈的情形。而且，返回机制与要处理的异常的类型相关。

如果要从返回地址在链接寄存器中的异常中返回，可以执行MOVS和SUBS指令，它们都是目的寄存器为PC时所使用指令的特殊版本。当从IRQ、FIQ或数据退出等异常返回时，必须修改PC的值。在前一种情形，PC的值应减4。而在后一种情形，PC的值将减8，以再次执行故障指令。

如果异常处理例程将返回地址拷贝到栈种，必须使用一个有些许不同的机制。在一般情况下，可以使用下面的指令从pc被保存在栈种的子程序种返回：

LDMFD r13！,{r0-r4,pc}