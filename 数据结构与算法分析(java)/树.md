# 树
###### 2019年4月13日
###### 15:48
### 树
树可以用几种方式定义。定义树的一种自然的方式是递归的方式。一棵树是一些节点的集合。这个集合可以是空集；若不是空集，则树由称作根的节点r以及0个或多个非空的(子)树T1,T2,···，Tk组成，这些子树中每一棵的根都被来自根r的一条有向的边所连结。每一棵子树的根叫作根r的儿子，而r是每一棵子树的根的父亲。  
每一个节点可以有任意多个儿子，也可能是0个儿子。没有儿子的节点称为树叶(leaf);具有相同父亲的节点为兄弟(siblings)。在一棵树中从根到每个节点恰好存在一条路径。对任意节点ni，ni的深度为从根到ni的唯一的路径长。ni的高是从ni到一片树叶的最长路径的长。

### 树的实现
实现树的一种方法可以实在每一个节点除数据外还要由一些链，使得该节点有一个链指向它。通常将每个节点的所有儿子都放在树节点的链表中。

### 二叉树
二叉树是一棵树，其中每个节点都不能有多于两个的儿子。二叉树的一个性质是一棵平均二叉树的深度要比节点个数小的多。分析表明，其平均深度为O(√N)。

### 二叉树的实现
因为一个二叉树最多有两个节点，所以我们可以保存直接链接到它们的链。在声名中，节点就是由element(元素)的信息加上两个到其他节点的引用组成的结构
```
class BinaryNode
{
  Object element;//当前节点的数据
  BinaryNode left;
  BinaryNode right;

}
```
### 二叉查找树
对于树中的每个节点x，它的左子树中所有项的值小于x中的项，而它的右子树中所有项的值大于x中的项。
```
public class BinarySearchTree<AnyType extends Comparable<? super AnyType>>
{
  private static class BinaryNode<AnyType>
  {
    BinaryNode( AnyType theElement )
        { this( theElement, null, null ); }

    BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        { element = theElement; left = lt; right = rt; }

    AnyType element;
    BinaryNode<AnyType> left;
    BinaryNode<AnyType> right;
  }

  private BinaryNode<AnyType> root;

  public BinarySearchTree( )
      { root = null; }

  public void makeEmpty( )
      { root = null; }
  public boolean isEmpty( )
      { return root == null; }

  public boolean contains( AnyType x )
      { return contains( x, root ); }
  public AnyType findMin( )
  {
    if( isEmpty( ) )
        throw new UnderflowException( );
    return findMin( root ).element;
  }
  public AnyType findMax( )
  {
    if( isEmpty( ) )
        throw new UnderflowException( );
    return findMax( root ).element;
  }
  public void insert( AnyType x )
      { root = insert( x, root ); }
  public void remove( AnyType x )
      { root = remove( x, root ); }
  public void printTree( )
  {
  if( isEmpty( ) )
      System.out.println( "Empty tree" );
  Else
      printTree( root );
  }

  private boolean contains( AnyType x, BinaryNode<AnyType> t )
  {
    if( t == null )
        return false;

    int compareResult = x.compareTo( t.element );

    if( compareResult < 0 )
        return contains( x, t.left );
    else if( compareResult > 0 )
        return contains( x, right );
    else
        return true;
  }
  private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
  {
    if( t == null )
        return null;
    else if( t.left == null )
        return t;
    return findMin( t.left );
  }
  private BinaryNode<AnyType> findMax( BianryNode<AnyType> t )
  {
    if( t != null )
        while( t.right != null )
            t = t.right;

    return t;
  }
  private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
  {
    if( t == null )
        return new BinaryNode<>( x, null, null );

    int compareResult = x.compareTo( t.element );

    if( compareResult < 0 )
        t.left = insert( x, t.left );
    else if( compareResult > 0 )
        t.right = insert( x, t.right);
    esle ;
    return t;
  }
  private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
  {
    if( t == null )
        return t;

    int cmopareResult = x.compareTo( t.element );

    if( compareResult < 0 )
         t.left = remove( x, t.left );
    else if( compareResult > 0 )
        t.right = remove( x, t.right );
    else if( t.left != null && t.right != null )
    {
        t.element = findMin( t.right ).element;
        t.right = remove( t.element, t.right);
    }
    else
        t = ( t.left != null ) ? t.left : t.right;
    return t;
  }
  private void printTree( BinaryNode<AnyType> t )
  {
    if( t != null )
    {
      printTree( t.left );
      System.out.println( t.element );
      printTree( t.right );
    }
  }
}
```

### AVL树
AVL树是带有平衡条件的二叉查找树。这个平衡条件必须要容易保持，而且它保证树的深度须是O(log N)。  
一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。在高度为h的AVL树中，最少节点数S(h) = S(h-1) + S(h-2) + 1。  
出去可能的插入外，所有的树操作都可以以时间O(logN)执行。当进行插入操作时我们需要更新通向根节点路径上的那些节点的所有平衡信息，而插入一个节点可能破坏AVL树的特性。如果发生这种情况，那么就要在考虑这一步插入完成之前恢复平衡的性质。事实上，这总可以通过对树进行简单的修正来做到，我们称其为旋转。
```
/**
 Avl树类
 */
public static class AvlTree<AnyType extends Comparable<? super AnyType> >
{
  /**
   Avl节点类，含有单值实例函数和带有节点的实例函数
   */
  public static class AvlNode<AnyType>
  {
    AvlNode( AnyType theElement )
        { this( theElement, null, null ); }
    AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        { element = theEle    { element = theElement; left = lt; right = rt; height = 0; }

    AnyType element;
    AvlNode<AnyType> left;
    AvlNode<AnyType> right;
    int height;
  }
  /**
   计算节点的高度函数
   */
  private int height( AvlNode<AnyType> t )
      { return t == null ? -1 : t.height; }
  /**
   插入函数
   */
  private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t )
  {
    if( t == null )//如果节点为空，则插入动作变为实例化一个新节点，插入函数结束
        return new AvlNode<>( x, null, null );
    //比较要插入的值与当前节点的值，计算要插入的位置
    int compareResult = x.compareTo( t.element );

    if( compareResult < 0 )
        t.left = insert( x, t.left );
    else if( compareResult > 0 )
        t.right = insert( x, t.right );
    else
        ;
    return balance( t );
  }

  private static finall int ALLOWED_IMBALANCE = 1;//平衡允许的高度差

  /**
   平衡函数
   */
  private AvlNode<AnyType> balance( AvlNode<AnyType> t )
  {
    if( t == null )//空节点无需平衡
        return t;

    if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )//判读左儿子和右儿子谁高，选择选择方向
        if( height( t.left.left ) >= height( t.left.right ) )//判断左子树和右子树谁高，选择旋转方式
            t = rotateWithLeftChild( t );
        else
            t = doubleWithLeftChild( t );
    else
    if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
        if( height( t.right.right ) >= height( t.right.left )
            t = rotateWithRightChild( t );
      else
            t = doubleWithRightChild( t );

    t.height = Math.max( height( t.left ), height( t.right ) ) + 1;//重新计算节点的高度
    return t;
  }
  priavate AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
  {
    AvlNode<AnyType> k1 = k2.left;
    k2.left = k1.right;
    k1.right = k2;
    k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
    k1.height = Math.max( height( k1.left ), k2.height ) + 1;
    return k1;
  }
  private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
  {
    k3.left = rotateWithRightChild( k3.left );
    return rotateWithLeftChild( k3 );
  }
  private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
  {
    if( t == null )
        return t;
    int compareResult = x.compareTo( t.element );

    if( compareResult < 0 )
        t.left = remove( x, t.left );
    else if( compareResult > 0 )
        t.right = remove( x, t.right );
    else if( t.left != null && t.right != null )
    {
      t.element = findMin( t.right ).element;
      t.right = remove( t.element, t.right );
    }
    else
        t = ( t.left != null ) ? t.left : t.right;
    return balance( t );
  }
}
```
### 伸展树
伸展树保证从空树开始连续M次对树的操作最多花费O(MlogN)时间。  
一般来说，当M次操作的序列总的最坏情形运行时间为O(MlogN)时，我们就说它的摊还运行时间为O(f(N))。因此，一棵伸展树每次操作的摊还代价时O(log(N))。  
伸展树的基本想法是，当一个节点被访问后，它要经过一系列AVL树的旋转被推到根上。如果一个节点很深，那么在其路径上就存在许多也相对较深的节点，通过重新构造可以减少对所有这些节点的进一步访问所花费的时间。因此，如果节点过深，那么我们要求重新构造应具有平衡这棵树的作用。
###### 一个简单的想法（不能直接使用）
实施上面描述的重新构造的一种方法是执行单旋转，从底向上进行。这意味着我们将在访问路径上的每一个节点和它们的父节点实施旋转。  
不足的是它把另外一个节点几乎推向和访问节点以前那么深。而对那个节点的访问又将把另外的节点向深处推进，如此等等。
###### 展开
展开的思路类似于上面介绍的旋转的想法，不过在旋转如何实施上我们稍加有些选择的余地。仍然从底部向上沿着访问路径旋转。令X是在访问路径上的一个(非根)节点，我们将在这个路径上实施旋转操作。如果X的父节点是根，那么只要旋转X和树根。否则，X就有父亲(P)和祖父(G)，存在两种情况以及对称的情形要考虑。第一种情况是之字形，我们就执行一次就像AVL双选转那样的双旋转。否则，出现另一种一字形：X和P或者都是左儿子或者右儿子。在这种情况下，我们把左边的树换成右边的树，或者把右边的树换成左边的树。
###### 再探树的遍历
```
public void printTree()
{
  if(isEmpty())
    System.out.println( "Empty tree" );
  else
    printTree( root );

  private void printTree( BinaryNode<Anytype> t )
  {
    if( t != null )
    {
      printTree( t.left );
      System.out.println( t.element );
      printTree( t.right );
    }

  }
}
```
正如我们所看到的，这类例程当用于树的时候则称为**中序遍历**。一个中序遍历的一般方法是首先处理左子树，然后是当前节点，最后处理右子树。这个算法有趣的是除它简单的特性外，还在于其总的运行时间是O(N)。这是因为在树的每一个节点处进行的工作是常数时间的。每一个节点访问一次，而在每一个节点进行的工作是检查是否null、建立两个方法调用、并执行println。由于在每个节点的工作花费常数时间以及总共有N个节点，因此运行时间为O(N)。  
有时我们需要先处理两棵子树然后才能处理当前节点。例如，为了计算一个节点的高度，首先需要知道它的子树的高度。由于检查一些特殊情况总是有益的————当涉及递归时尤为重要，因此要注意这个例程声明树叶的高度为零，这是正确的。这种一般的遍历顺序叫作**后序遍历**。
```
private int height( BinaryNode<AnyType> t )
{
  if( t == null )
    return -1;
  else
    return 1+Math.max( height( t.left ), height( t.right ) );
}
```
我们见过的第三种遍历格式为**先序遍历**。这里当前节点在其儿子节点之前处理。这种遍历是有用的。比如，如果想要用其深度标记每一个点，那么这种遍历就会用到。  
第四种遍历用得很少，叫作**层序遍历**。在层序遍历中，所有深度为d的节点要在深度d+1的节点之前进行处理。层序遍历与其他类型的遍历不同的地方在于它不是递归执行的；他用到队列，而不使用递归所默示的栈。
###### B树
不平衡的二叉查找树是一个灾难。在最坏情况下它具有线性的深度，从而可能需要1000万次磁盘访问。平均来看，一次成功的查找可能需要1.38logN次磁盘访问。平均一次查找需要32次磁盘访问，或5秒的时间。AVL树多少要好一些。1.44logN的最坏情形不可能发生，典型的情况是非常接近于logN。这样，一棵AVL树平均将使用大约25次磁盘访问，需要的时间是4秒。  
我们想要把磁盘访问次数减小到一个非常小的常数；而且我们愿意写一个复杂的程序来做这件事，因为在合理情况下机器指令基本上是不占时间的。  
二叉查找树是不可行的。解法直觉上来看是简单的：如果有更多的分支，那么就有更少的高度。随着分支增加，树的深度在减少。一棵完全二叉树的高度大约为log<small style="font-size: 8px">2</small>N，而一棵完全M叉树的高度大约是log<small style="font-size: 8px">M</small>N。
我们可以以与建立二叉查找树大致相同的方式建立M叉查找树。在二叉查找树中，需要一个关键字来决定两个分支到底取用哪个分支；而在M叉查找树中需要M1个关键字来决定选取哪个分支。为使这种方案在最坏的情形下有效，需要保证M叉查找树以某种方式得到平衡。否则，像二叉查找树，他可能退化成一个链表。  
实现这种想法的一种方法是使用B树。这里描述基本的B树。许多的变种和改进都是可能的。  
阶为M的B树是一棵具有下列特性的树：
1. 数据项存储在树叶上。
2. 非叶节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字
3. 树的根或者是一片树叶，或者其儿子数在2和M之间。
4. 除根外，所有非树叶节点的儿子数在M/2和M之间。
5. 所有的树叶都在相同的深度上并有L/2和L之间个数据项，L的确定稍后描述。
